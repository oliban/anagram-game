// Generated: 2025-07-10 11:38:22
// Swift API Surface Map for directory: .
// Found 17 Swift files
// Generated by Swift Code Map Generator

// === ./Anagram GameTests/Anagram_GameTests.swift ===

// Generated: 2025-07-10 11:38:22

import XCTest

final class Anagram_GameTests: XCTestCase  {
}


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Anagram GameTests/GameModelTests.swift ===

// Generated: 2025-07-10 11:38:22

import XCTest

final class GameModelTests: XCTestCase  {
    var gameModel: GameModel!
}


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Anagram GameTests/PhysicsGameSceneTests.swift ===

// Generated: 2025-07-10 11:38:22

import XCTest
import SpriteKit
import CoreMotion

final class PhysicsGameSceneTests: XCTestCase  {
    var gameModel: GameModel!
    var scene: PhysicsGameScene!
    var testSize: CGSize!
}
final class MockTileGroupingTests: XCTestCase  {
}
class MockLetterTile {
    let letter: String
    let position: CGPoint
}
final class TileSelectionTests: XCTestCase  {
}
final class ScoringPerformanceTests: XCTestCase  {
}

func groupTilesByProximity(tiles: [MockLetterTile], radius: CGFloat) -> [[MockLetterTile]]
func validateWordsMatch(target: [String], found: [String]) -> Bool
static func == (lhs: MockLetterTile, rhs: MockLetterTile) -> Bool
func hash(into hasher: inout Hasher)
func findBestTileCombination(for targetLetters: [Character], from allTiles: [MockLetterTile], excluding usedTiles: Set<MockLetterTile>) -> [MockLetterTile]?
func generateTileCombinations(for targetLetters: [Character], from tilesByLetter: [Character: [MockLetterTile]]) -> [[MockLetterTile]]
func generateCombinations(remainingLetters: [Character], currentCombination: [MockLetterTile], usedTiles: Set<MockLetterTile>) -> [[MockLetterTile]]

extension MockLetterTile: Hashable  {
}

////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Anagram GameUITests/Anagram_GameUITests.swift ===

// Generated: 2025-07-10 11:38:22

import XCTest

final class Anagram_GameUITests: XCTestCase  {
}


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Anagram GameUITests/Anagram_GameUITestsLaunchTests.swift ===

// Generated: 2025-07-10 11:38:22

import XCTest

final class Anagram_GameUITestsLaunchTests: XCTestCase  {
}


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Anagram_GameApp.swift ===

// Generated: 2025-07-10 11:38:22

import SwiftUI
import SwiftData
import UIKit

class AppDelegate: NSObject, UIApplicationDelegate  {
}
struct Anagram_GameApp: App  {
}


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Models/GameModel.swift ===

// Generated: 2025-07-10 11:38:22

import Foundation
import SwiftData
import Combine

protocol MessageTileSpawner: AnyObject  {
    func spawnMessageTile(message: String)
}

class GameModel: ObservableObject  {
    var currentSentence: String
    var scrambledLetters: [String]
    var gameState: GameState
    var wordsCompleted: Int
    var customPhraseInfo: String
    weak var messageTileSpawner: MessageTileSpawner?
    var currentPhraseId: String?
    var currentHints: [String]
    var currentScore: Int
    var hintsUsed: Int
    var phraseDifficulty: Int
    var playerId: String?
    var playerName: String?
    var networkManager: NetworkManager?
    var currentCustomPhrase: CustomPhrase?
}

func startNewGame(isUserInitiated: Bool = false) async
func resetGame()
func validateWordCompletion(formedWords: [String]) -> Bool
func checkWordFromTiles(at positions: [CGPoint]) -> String?
func getExpectedWords() -> [String]
func completeGame()
func skipCurrentGame() async
func addHint(_ hint: String)
func refreshPhrasesForLobby() async


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Models/Item.swift ===

// Generated: 2025-07-10 11:38:22

import Foundation
import SwiftData

final class Item {
    var timestamp: Date
}


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Models/NetworkManager.swift ===

// Generated: 2025-07-10 11:38:22

import Foundation
import Network
import UIKit
import SocketIO

struct Player: Codable, Identifiable, Equatable  {
    let id: String
    let name: String
    let lastSeen: Date
    let isActive: Bool
    let phrasesCompleted: Int
}
struct CustomPhrase: Codable, Identifiable, Equatable  {
    let id: String
    let content: String
    let senderId: String
    let targetId: String
    let createdAt: Date
    let isConsumed: Bool
    let senderName: String
    let language: String // Language code for LanguageTile feature
}
struct HintStatus: Codable  {
    let hintsUsed: [UsedHint]
    let nextHintLevel: Int?
    let hintsRemaining: Int
    let currentScore: Int
    let nextHintScore: Int?
    let canUseNextHint: Bool
}
struct ScorePreview: Codable  {
    let noHints: Int
    let level1: Int
    let level2: Int
    let level3: Int
}
struct HintResponse: Codable  {
    let success: Bool
    let hint: HintData
    let scorePreview: ScorePreview
    let timestamp: String
}
struct PhrasePreview: Codable  {
    let success: Bool
    let phrase: PhraseData
    let timestamp: String
}
struct CompletionResult: Codable  {
    let success: Bool
    let completion: CompletionData
    let timestamp: String
}
private struct RegistrationRequestBody: Encodable  {
    let name: String
}
class NetworkManager: ObservableObject  {
    @Published
    var connectionStatus: ConnectionStatus
    @Published
    var isConnected: Bool
    @Published
    var currentPlayer: Player?
    @Published
    var onlinePlayers: [Player]
    @Published
    var lastReceivedPhrase: CustomPhrase?
    @Published
    var hasNewPhrase: Bool
    @Published
    var justReceivedPhrase: CustomPhrase?
}
public struct DifficultyAnalysis: Codable  {
    let phrase: String
    let language: String
    let score: Double
    let difficulty: String
    let timestamp: String
}
public struct PlayerStats: Codable  {
    let dailyScore: Int
    let dailyRank: Int
    let weeklyScore: Int
    let weeklyRank: Int
    let totalScore: Int
    let totalRank: Int
    let totalPhrases: Int
}
public struct LeaderboardEntry: Codable  {
    let rank: Int
    let playerName: String
    let totalScore: Int
    let phrasesCompleted: Int
}

func connect(playerId: String)
func disconnect()
func registerPlayer(name: String) async -> Bool
func fetchOnlinePlayers() async
func sendPhrase(content: String, targetId: String, clue: String? = nil, language: String = "en") async -> Bool
func fetchPhrasesForCurrentPlayer() async -> [CustomPhrase]
func consumePhrase(phraseId: String) async -> Bool
func skipPhrase(phraseId: String) async -> Bool
func getPhrasePreview(phraseId: String) async -> PhrasePreview?
func useHint(phraseId: String, level: Int) async -> HintResponse?
func getHintStatus(phraseId: String) async -> HintStatus?
func completePhrase(phraseId: String, completionTime: Int = 0) async -> CompletionResult?
func startPeriodicPlayerListFetch()
func stopPeriodicPlayerListFetch()
func getPlayerStats(playerId: String) async throws -> PlayerStats
func getLeaderboard(period: String, limit: Int = 10) async throws -> [LeaderboardEntry]
func getOnlinePlayersCount() async throws -> Int
func testConnection() async -> Result<Bool, NetworkError>
func connect()
func sendManualPing()
func analyzeDifficulty(phrase: String, language: String = "en") async -> DifficultyAnalysis?

extension DateFormatter {
}

////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Views/ContentView.swift ===

// Generated: 2025-07-10 11:38:22

import SwiftUI
import SwiftData
import Foundation

struct TimeoutError: Error  {
}

func withTimeout<T>(seconds: TimeInterval, operation: @escaping () async throws -> T) async throws -> T


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Views/HintButton.swift ===

// Generated: 2025-07-10 11:38:22

import SwiftUI

struct HintButton: View  {
    let phraseId: String
    let onHintUsed: (String) -> Void
}


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Views/LobbyView.swift ===

// Generated: 2025-07-10 11:38:22

import SwiftUI

struct LobbyView: View  {
    @ObservedObject
    var gameModel: GameModel
}
struct StatCard: View  {
    let title: String
    let value: String
    let rank: String
}
struct LeaderboardRow: View  {
    let rank: Int
    let playerName: String
    let score: Int
    let phrasesCompleted: Int
    let isCurrentPlayer: Bool
}


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Views/OnlinePlayersView.swift ===

// Generated: 2025-07-10 11:38:22

import SwiftUI

struct OnlinePlayersView: View  {
}
struct PlayerRowView: View  {
    let player: Player
    let isCurrentPlayer: Bool
}


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Views/PhraseCreationView.swift ===

// Generated: 2025-07-10 11:38:22

import SwiftUI

struct PhraseCreationView: View  {
    @Binding
    var isPresented: Bool
}
struct PhraseCreationView_Previews: PreviewProvider  {
}


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Views/PhysicsGameView.swift ===

// Generated: 2025-07-10 11:38:22

import SwiftUI
import SpriteKit
import CoreMotion

protocol RespawnableTile: SKSpriteNode  {
    var isBeingDragged: Bool
}

struct HintButtonView: View  {
    let phraseId: String
    let gameModel: GameModel
    let gameScene: PhysicsGameScene?
    let onHintUsed: (String) -> Void
}
struct PhysicsCategories {
    static let tile: UInt32
    static let shelf: UInt32
    static let floor: UInt32
    static let wall: UInt32
}
struct PhysicsGameView: View  {
    @ObservedObject
    var gameModel: GameModel
    @Binding
    var showingGame: Bool
}
class PhysicsGameScene: SKScene, MessageTileSpawner  {
    var motionManager: CMMotionManager?
    var onCelebration: ((String) -> Void)?
    var onJolt: (() -> Void)?
    var celebrationText: String
}
class LetterTile: SKSpriteNode, RespawnableTile  {
    let letter: String
}
class InformationTile: SKSpriteNode, RespawnableTile  {
}
class ScoreTile: InformationTile  {
}
class MessageTile: InformationTile  {
}
class LanguageTile: InformationTile  {
    var currentLanguage: String
}
struct SpriteKitView: UIViewRepresentable  {
    let scene: SKScene
}

func updateScoreTile()
func updateLanguageTile()
func spawnMessageTile(message: String)
func updateGravity(from gravity: CMAcceleration)
func triggerQuake()
func triggerQuickQuake()
func triggerHint()
func showHint1()
func showHint2()
func showHint3()
func resetGame()
func generateCombinations(remainingLetters: [Character], currentCombination: [LetterTile], usedTiles: Set<LetterTile>) -> [[LetterTile]]
func didBegin(_ contact: SKPhysicsContact)

extension PhysicsGameScene: SKPhysicsContactDelegate  {
}

////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./Views/PlayerRegistrationView.swift ===

// Generated: 2025-07-10 11:38:22

import SwiftUI

struct PlayerRegistrationView: View  {
    @Binding
    var isPresented: Bool
}


////////////////////////////////////////////////////////////////////////////////////////////////////

// === ./code_map.swift ===

// Generated: 2025-07-10 11:38:22

import XCTest
import XCTest
import XCTest
import SpriteKit
import CoreMotion
import XCTest
import XCTest
import SwiftUI
import SwiftData
import UIKit
import Foundation
import SwiftData
import Combine
import Foundation
import SwiftData
import Foundation
import Network
import UIKit
import SocketIO
import SwiftUI
import SwiftData
import Foundation
import SwiftUI
import SwiftUI
import SwiftUI
import SwiftUI
import SwiftUI
import SpriteKit
import CoreMotion
import SwiftUI
import Foundation
import AppKit
import UIKit
import SwiftUI
import DeveloperToolsSupport
import class Foundation.Bundle
import class Foundation.ProcessInfo
import struct Foundation.URL
import PackageDescription
import Foundation
import Foundation
import zlib
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import CommonCrypto
import Foundation
import Foundation
import Foundation
import Network
import Foundation
import Foundation
import Foundation
import Network
import Foundation
import XCTest
import XCTest
import Foundation
import Foundation
import XCTest
import UIKit
import UIKit
import Starscream
import UIKit
import UIKit
import Starscream
import UIKit
import Foundation
import UIKit
import Starscream
import PackageDescription
import Dispatch
import Foundation
import Dispatch
import Foundation
import Foundation
import Foundation
import Dispatch
import Foundation
import Foundation
import Starscream
import Dispatch
import Foundation
import Foundation
import Foundation
import Dispatch
import Foundation
import Starscream
import Foundation
import Foundation
import Foundation
import Foundation
import Starscream
import Foundation
import Starscream
import Dispatch
import Foundation
import Dispatch
import Foundation
import Foundation
import Foundation
import Foundation
import Starscream
import Foundation
import Foundation
import XCTest
import XCTest
import XCTest
import XCTest
import SocketIO
import Dispatch
import Foundation
import XCTest
import XCTest
import XCTest
import XCTest
import Starscream
import Foundation
import XCTest
import XCTest
import XCTest
import SpriteKit
import CoreMotion
import XCTest
import XCTest
import SwiftUI
import SwiftData
import UIKit
import Foundation
import SwiftData
import Combine
import Foundation
import SwiftData
import Foundation
import Network
import UIKit
import SocketIO
import SwiftUI
import SwiftData
import Foundation
import SwiftUI
import SwiftUI
import SwiftUI
import SwiftUI
import SwiftUI
import SpriteKit
import CoreMotion
import SwiftUI
import Foundation
import AppKit
import UIKit
import SwiftUI
import DeveloperToolsSupport
import class Foundation.Bundle
import class Foundation.ProcessInfo
import struct Foundation.URL
import PackageDescription
import Foundation
import Foundation
import zlib
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import CommonCrypto
import Foundation
import Foundation
import Foundation
import Network
import Foundation
import Foundation
import Foundation
import Network
import Foundation
import XCTest
import XCTest
import Foundation
import Foundation
import XCTest
import UIKit
import UIKit
import Starscream
import UIKit
import UIKit
import Starscream
import UIKit
import Foundation
import UIKit
import Starscream
import PackageDescription
import Dispatch
import Foundation
import Dispatch
import Foundation
import Foundation
import Foundation
import Dispatch
import Foundation
import Foundation
import Starscream
import Dispatch
import Foundation
import Foundation
import Foundation
import Dispatch
import Foundation
import Starscream
import Foundation
import Foundation
import Foundation
import Foundation
import Starscream
import Foundation
import Starscream
import Dispatch
import Foundation
import Dispatch
import Foundation
import Foundation
import Foundation
import Foundation
import Starscream
import Foundation
import Foundation
import XCTest
import XCTest
import XCTest
import XCTest
import SocketIO
import Dispatch
import Foundation
import XCTest
import XCTest
import XCTest
import XCTest
import Starscream
import Foundation
import XCTest
import XCTest
import XCTest
import SpriteKit
import CoreMotion
import XCTest
import XCTest
import SwiftUI
import SwiftData
import UIKit
import Foundation
import SwiftData
import Combine
import Foundation
import SwiftData
import Foundation
import Network
import UIKit
import SocketIO
import SwiftUI
import SwiftData
import Foundation
import SwiftUI
import SwiftUI
import SwiftUI
import SwiftUI
import SwiftUI
import SpriteKit
import CoreMotion
import SwiftUI
import Foundation
import AppKit
import UIKit
import SwiftUI
import DeveloperToolsSupport
import class Foundation.Bundle
import class Foundation.ProcessInfo
import struct Foundation.URL
import PackageDescription
import Foundation
import Foundation
import zlib
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import Foundation
import CommonCrypto
import Foundation
import Foundation
import Foundation
import Network
import Foundation
import Foundation
import Foundation
import Network
import Foundation
import XCTest
import XCTest
import Foundation
import Foundation
import XCTest
import UIKit
import UIKit
import Starscream
import UIKit
import UIKit
import Starscream
import UIKit
import Foundation
import UIKit
import Starscream
import PackageDescription
import Dispatch
import Foundation
import Dispatch
import Foundation
import Foundation
import Foundation
import Dispatch
import Foundation
import Foundation
import Starscream
import Dispatch
import Foundation
import Foundation
import Foundation
import Dispatch
import Foundation
import Starscream
import Foundation
import Foundation
import Foundation
import Foundation
import Starscream
import Foundation
import Starscream
import Dispatch
import Foundation
import Dispatch
import Foundation
import Foundation
import Foundation
import Foundation
import Starscream
import Foundation
import Foundation
import XCTest
import XCTest
import XCTest
import XCTest
import SocketIO
import Dispatch
import Foundation
import XCTest
import XCTest
import XCTest
import XCTest
import Starscream
import Foundation

protocol MessageTileSpawner: AnyObject   {
    func spawnMessageTile(message: String)
}
public protocol CompressionHandler {
    func load(headers: [String: String])
    func decompress(data: Data, isFinal: Bool) -> Data?
    func compress(data: Data) -> Data?
}
public protocol EngineDelegate: AnyObject   {
    func didReceive(event: WebSocketEvent)
}
public protocol Engine {
    func register(delegate: EngineDelegate)
    func start(request: URLRequest)
    func stop(closeCode: UInt16)
    func forceStop()
    func write(data: Data, opcode: FrameOpCode, completion: (() -> ())?)
    func write(string: String, completion: (() -> ())?)
}
public protocol FrameCollectorDelegate: AnyObject   {
    func didForm(event: FrameCollector.Event)
    func decompress(data: Data, isFinal: Bool) -> Data?
}
public protocol FramerEventClient: AnyObject   {
    func frameProcessed(event: FrameEvent)
}
public protocol Framer {
    func add(data: Data)
    func register(delegate: FramerEventClient)
    func createWriteFrame(opcode: FrameOpCode, payload: Data, isCompressed: Bool) -> Data
    func updateCompression(supports: Bool)
    func supportsCompression() -> Bool
}
public protocol MyWSArrayType {
}
public protocol HTTPHandlerDelegate: AnyObject   {
    func didReceiveHTTP(event: HTTPEvent)
}
public protocol HTTPHandler {
    func register(delegate: HTTPHandlerDelegate)
    func convert(request: URLRequest) -> Data
    func parse(data: Data) -> Int
}
public protocol HTTPServerDelegate: AnyObject   {
    func didReceive(event: HTTPEvent)
}
public protocol HTTPServerHandler {
    func register(delegate: HTTPServerDelegate)
    func parse(data: Data)
    func createResponse(headers: [String: String]) -> Data
}
public protocol CertificatePinning: AnyObject   {
    func evaluateTrust(trust: SecTrust, domain: String?, completion: ((PinningState) -> ()))
}
public protocol HeaderValidator: AnyObject   {
    func validate(headers: [String: String], key: String) -> Error?
}
public protocol Connection {
    func write(data: Data, opcode: FrameOpCode)
}
public protocol ConnectionDelegate: AnyObject   {
    func didReceive(event: ServerEvent)
}
public protocol Server {
    func start(address: String, port: UInt16) -> Error?
}
public protocol WebSocketClient: AnyObject   {
    func connect()
    func disconnect(closeCode: UInt16)
    func write(string: String, completion: (() -> ())?)
    func write(stringData: Data, completion: (() -> ())?)
    func write(data: Data, completion: (() -> ())?)
    func write(ping: Data, completion: (() -> ())?)
    func write(pong: Data, completion: (() -> ())?)
}
public protocol WebSocketDelegate: AnyObject   {
    func didReceive(event: WebSocketEvent, client: WebSocketClient)
}
public protocol TransportEventClient: AnyObject   {
    func connectionChanged(state: ConnectionState)
}
public protocol Transport: AnyObject   {
    func register(delegate: TransportEventClient)
    func connect(url: URL, timeout: Double, certificatePinning: CertificatePinning?)
    func disconnect()
    func write(data: Data, completion: @escaping ((Error?) -> ()))
    var usingTLS: Bool
}
public protocol ConfigSettable {
}
protocol ClientOption : CustomStringConvertible, Equatable   {
    func getSocketIOOptionValue() -> Any
}
public protocol SocketIOClientSpec : AnyObject   {
    var anyHandler: ((SocketAnyEvent) -> ())?
    var handlers: [SocketEventHandler]
    var manager: SocketManagerSpec?
    var nsp: String
    var rawEmitView: SocketRawView
    var sid: String?
    var status: SocketIOStatus
    func connect(withPayload payload: [String: Any]?)
    func connect(withPayload payload: [String: Any]?, timeoutAfter: Double, withHandler handler: (() -> ())?)
    func didConnect(toNamespace namespace: String, payload: [String: Any]?)
    func didDisconnect(reason: String)
    func didError(reason: String)
    func disconnect()
    func emit(_ event: String, _ items: SocketData..., completion: (() -> ())?)
    func emit(_ event: String, with items: [SocketData], completion: (() -> ())?)
    func emitAck(_ ack: Int, with items: [Any])
    func emitWithAck(_ event: String, _ items: SocketData...) -> OnAckCallback
    func emitWithAck(_ event: String, with items: [SocketData]) -> OnAckCallback
    func handleAck(_ ack: Int, data: [Any])
    func handleClientEvent(_ event: SocketClientEvent, data: [Any])
    func handleEvent(_ event: String, data: [Any], isInternalMessage: Bool, withAck ack: Int)
    func handlePacket(_ packet: SocketPacket)
    func leaveNamespace()
    func joinNamespace(withPayload payload: [String: Any]?)
    func off(clientEvent event: SocketClientEvent)
    func off(_ event: String)
    func off(id: UUID)
    func on(_ event: String, callback: @escaping NormalCallback) -> UUID
    func on(clientEvent event: SocketClientEvent, callback: @escaping NormalCallback) -> UUID
    func once(clientEvent event: SocketClientEvent, callback: @escaping NormalCallback) -> UUID
    func once(_ event: String, callback: @escaping NormalCallback) -> UUID
    func onAny(_ handler: @escaping (SocketAnyEvent) -> ())
    func removeAllHandlers()
    func setReconnecting(reason: String)
}
public protocol SocketEngineClient {
    func engineDidError(reason: String)
    func engineDidClose(reason: String)
    func engineDidOpen(reason: String)
    func engineDidReceivePing()
    func engineDidReceivePong()
    func engineDidSendPing()
    func engineDidSendPong()
    func parseEngineMessage(_ msg: String)
    func parseEngineBinaryData(_ data: Data)
    func engineDidWebsocketUpgrade(headers: [String: String])
}
public protocol SocketEnginePollable: SocketEngineSpec   {
    var invalidated: Bool
    var postWait: [Post]
    var session: URLSession?
    var waitingForPoll: Bool
    var waitingForPost: Bool
    func doPoll()
    func sendPollMessage(_ message: String, withType type: SocketEnginePacketType, withData datas: [Data], completion: (() -> ())?)
    func stopPolling()
}
public protocol SocketEngineSpec: AnyObject   {
    var client: SocketEngineClient?
    var closed: Bool
    var compress: Bool
    var connected: Bool
    var connectParams: [String: Any]?
    var cookies: [HTTPCookie]?
    var engineQueue: DispatchQueue
    var extraHeaders: [String: String]?
    var fastUpgrade: Bool
    var forcePolling: Bool
    var forceWebsockets: Bool
    var polling: Bool
    var probing: Bool
    var sid: String
    var socketPath: String
    var urlPolling: URL
    var urlWebSocket: URL
    var version: SocketIOVersion
    var websocket: Bool
    var ws: WebSocket?
    func connect()
    func didError(reason: String)
    func disconnect(reason: String)
    func doFastUpgrade()
    func flushWaitingForPostToWebSocket()
    func parseEngineData(_ data: Data)
    func parseEngineMessage(_ message: String)
    func write(_ msg: String, withType type: SocketEnginePacketType, withData data: [Data], completion: (() -> ())?)
}
public protocol SocketEngineWebsocket: SocketEngineSpec   {
    var wsConnected: Bool
    func sendWebSocketMessage(_ str: String,
}
public protocol SocketManagerSpec : SocketEngineClient   {
    var defaultSocket: SocketIOClient
    var engine: SocketEngineSpec?
    var forceNew: Bool
    var handleQueue: DispatchQueue
    var nsps: [String: SocketIOClient]
    var reconnects: Bool
    var reconnectWait: Int
    var reconnectWaitMax: Int
    var randomizationFactor: Double
    var socketURL: URL
    var status: SocketIOStatus
    var version: SocketIOVersion
    func connect()
    func connectSocket(_ socket: SocketIOClient, withPayload: [String: Any]?)
    func didDisconnect(reason: String)
    func disconnect()
    func disconnectSocket(_ socket: SocketIOClient)
    func disconnectSocket(forNamespace nsp: String)
    func emitAll(_ event: String, _ items: SocketData...)
    func reconnect()
    func removeSocket(_ socket: SocketIOClient) -> SocketIOClient?
    func socket(forNamespace nsp: String) -> SocketIOClient
}
public protocol SocketParsable : AnyObject   {
    func parseBinaryData(_ data: Data) -> SocketPacket?
    func parseSocketMessage(_ message: String) -> SocketPacket?
}
public protocol SocketDataBufferable : AnyObject   {
    var waitingPackets: [SocketPacket]
}
public protocol SocketLogger : AnyObject   {
    var log: Bool
    func log(_ message: @autoclosure () -> String, type: String)
    func error(_ message: @autoclosure () -> String, type: String)
}
public protocol SocketData {
    func socketRepresentation() throws -> SocketData
}
public protocol CompressionHandler {
    func load(headers: [String: String])
    func decompress(data: Data, isFinal: Bool) -> Data?
    func compress(data: Data) -> Data?
}
public protocol EngineDelegate: AnyObject    {
    func didReceive(event: WebSocketEvent)
}
public protocol Engine {
    func register(delegate: EngineDelegate)
    func start(request: URLRequest)
    func stop(closeCode: UInt16)
    func forceStop()
    func write(data: Data, opcode: FrameOpCode, completion: (() -> ())?)
    func write(string: String, completion: (() -> ())?)
}
public protocol FrameCollectorDelegate: AnyObject    {
    func didForm(event: FrameCollector.Event)
    func decompress(data: Data, isFinal: Bool) -> Data?
}
public protocol FramerEventClient: AnyObject    {
    func frameProcessed(event: FrameEvent)
}
public protocol Framer {
    func add(data: Data)
    func register(delegate: FramerEventClient)
    func createWriteFrame(opcode: FrameOpCode, payload: Data, isCompressed: Bool) -> Data
    func updateCompression(supports: Bool)
    func supportsCompression() -> Bool
}
public protocol MyWSArrayType {
}
public protocol HTTPHandlerDelegate: AnyObject    {
    func didReceiveHTTP(event: HTTPEvent)
}
public protocol HTTPHandler {
    func register(delegate: HTTPHandlerDelegate)
    func convert(request: URLRequest) -> Data
    func parse(data: Data) -> Int
}
public protocol HTTPServerDelegate: AnyObject    {
    func didReceive(event: HTTPEvent)
}
public protocol HTTPServerHandler {
    func register(delegate: HTTPServerDelegate)
    func parse(data: Data)
    func createResponse(headers: [String: String]) -> Data
}
public protocol CertificatePinning: AnyObject    {
    func evaluateTrust(trust: SecTrust, domain: String?, completion: ((PinningState) -> ()))
}
public protocol HeaderValidator: AnyObject    {
    func validate(headers: [String: String], key: String) -> Error?
}
public protocol Connection {
    func write(data: Data, opcode: FrameOpCode)
}
public protocol ConnectionDelegate: AnyObject    {
    func didReceive(event: ServerEvent)
}
public protocol Server {
    func start(address: String, port: UInt16) -> Error?
}
public protocol WebSocketClient: AnyObject    {
    func connect()
    func disconnect(closeCode: UInt16)
    func write(string: String, completion: (() -> ())?)
    func write(stringData: Data, completion: (() -> ())?)
    func write(data: Data, completion: (() -> ())?)
    func write(ping: Data, completion: (() -> ())?)
    func write(pong: Data, completion: (() -> ())?)
}
public protocol WebSocketDelegate: AnyObject    {
    func didReceive(event: WebSocketEvent, client: WebSocketClient)
}
public protocol TransportEventClient: AnyObject    {
    func connectionChanged(state: ConnectionState)
}
public protocol Transport: AnyObject    {
    func register(delegate: TransportEventClient)
    func connect(url: URL, timeout: Double, certificatePinning: CertificatePinning?)
    func disconnect()
    func write(data: Data, completion: @escaping ((Error?) -> ()))
    var usingTLS: Bool
}
public protocol ConfigSettable {
}
protocol ClientOption : CustomStringConvertible, Equatable    {
    func getSocketIOOptionValue() -> Any
}
public protocol SocketIOClientSpec : AnyObject    {
    var anyHandler: ((SocketAnyEvent) -> ())?
    var handlers: [SocketEventHandler]
    var manager: SocketManagerSpec?
    var nsp: String
    var rawEmitView: SocketRawView
    var sid: String?
    var status: SocketIOStatus
    func connect(withPayload payload: [String: Any]?)
    func connect(withPayload payload: [String: Any]?, timeoutAfter: Double, withHandler handler: (() -> ())?)
    func didConnect(toNamespace namespace: String, payload: [String: Any]?)
    func didDisconnect(reason: String)
    func didError(reason: String)
    func disconnect()
    func emit(_ event: String, _ items: SocketData..., completion: (() -> ())?)
    func emit(_ event: String, with items: [SocketData], completion: (() -> ())?)
    func emitAck(_ ack: Int, with items: [Any])
    func emitWithAck(_ event: String, _ items: SocketData...) -> OnAckCallback
    func emitWithAck(_ event: String, with items: [SocketData]) -> OnAckCallback
    func handleAck(_ ack: Int, data: [Any])
    func handleClientEvent(_ event: SocketClientEvent, data: [Any])
    func handleEvent(_ event: String, data: [Any], isInternalMessage: Bool, withAck ack: Int)
    func handlePacket(_ packet: SocketPacket)
    func leaveNamespace()
    func joinNamespace(withPayload payload: [String: Any]?)
    func off(clientEvent event: SocketClientEvent)
    func off(_ event: String)
    func off(id: UUID)
    func on(_ event: String, callback: @escaping NormalCallback) -> UUID
    func on(clientEvent event: SocketClientEvent, callback: @escaping NormalCallback) -> UUID
    func once(clientEvent event: SocketClientEvent, callback: @escaping NormalCallback) -> UUID
    func once(_ event: String, callback: @escaping NormalCallback) -> UUID
    func onAny(_ handler: @escaping (SocketAnyEvent) -> ())
    func removeAllHandlers()
    func setReconnecting(reason: String)
}
public protocol SocketEngineClient {
    func engineDidError(reason: String)
    func engineDidClose(reason: String)
    func engineDidOpen(reason: String)
    func engineDidReceivePing()
    func engineDidReceivePong()
    func engineDidSendPing()
    func engineDidSendPong()
    func parseEngineMessage(_ msg: String)
    func parseEngineBinaryData(_ data: Data)
    func engineDidWebsocketUpgrade(headers: [String: String])
}
public protocol SocketEnginePollable: SocketEngineSpec    {
    var invalidated: Bool
    var postWait: [Post]
    var session: URLSession?
    var waitingForPoll: Bool
    var waitingForPost: Bool
    func doPoll()
    func sendPollMessage(_ message: String, withType type: SocketEnginePacketType, withData datas: [Data], completion: (() -> ())?)
    func stopPolling()
}
public protocol SocketEngineSpec: AnyObject    {
    var client: SocketEngineClient?
    var closed: Bool
    var compress: Bool
    var connected: Bool
    var connectParams: [String: Any]?
    var cookies: [HTTPCookie]?
    var engineQueue: DispatchQueue
    var extraHeaders: [String: String]?
    var fastUpgrade: Bool
    var forcePolling: Bool
    var forceWebsockets: Bool
    var polling: Bool
    var probing: Bool
    var sid: String
    var socketPath: String
    var urlPolling: URL
    var urlWebSocket: URL
    var version: SocketIOVersion
    var websocket: Bool
    var ws: WebSocket?
    func connect()
    func didError(reason: String)
    func disconnect(reason: String)
    func doFastUpgrade()
    func flushWaitingForPostToWebSocket()
    func parseEngineData(_ data: Data)
    func parseEngineMessage(_ message: String)
    func write(_ msg: String, withType type: SocketEnginePacketType, withData data: [Data], completion: (() -> ())?)
}
public protocol SocketEngineWebsocket: SocketEngineSpec    {
    var wsConnected: Bool
    func sendWebSocketMessage(_ str: String,
}
public protocol SocketManagerSpec : SocketEngineClient    {
    var defaultSocket: SocketIOClient
    var engine: SocketEngineSpec?
    var forceNew: Bool
    var handleQueue: DispatchQueue
    var nsps: [String: SocketIOClient]
    var reconnects: Bool
    var reconnectWait: Int
    var reconnectWaitMax: Int
    var randomizationFactor: Double
    var socketURL: URL
    var status: SocketIOStatus
    var version: SocketIOVersion
    func connect()
    func connectSocket(_ socket: SocketIOClient, withPayload: [String: Any]?)
    func didDisconnect(reason: String)
    func disconnect()
    func disconnectSocket(_ socket: SocketIOClient)
    func disconnectSocket(forNamespace nsp: String)
    func emitAll(_ event: String, _ items: SocketData...)
    func reconnect()
    func removeSocket(_ socket: SocketIOClient) -> SocketIOClient?
    func socket(forNamespace nsp: String) -> SocketIOClient
}
public protocol SocketParsable : AnyObject    {
    func parseBinaryData(_ data: Data) -> SocketPacket?
    func parseSocketMessage(_ message: String) -> SocketPacket?
}
public protocol SocketDataBufferable : AnyObject    {
    var waitingPackets: [SocketPacket]
}
public protocol SocketLogger : AnyObject    {
    var log: Bool
    func log(_ message: @autoclosure () -> String, type: String)
    func error(_ message: @autoclosure () -> String, type: String)
}
public protocol SocketData {
    func socketRepresentation() throws -> SocketData
}
public protocol CompressionHandler {
    func load(headers: [String: String])
    func decompress(data: Data, isFinal: Bool) -> Data?
    func compress(data: Data) -> Data?
}
public protocol EngineDelegate: AnyObject     {
    func didReceive(event: WebSocketEvent)
}
public protocol Engine {
    func register(delegate: EngineDelegate)
    func start(request: URLRequest)
    func stop(closeCode: UInt16)
    func forceStop()
    func write(data: Data, opcode: FrameOpCode, completion: (() -> ())?)
    func write(string: String, completion: (() -> ())?)
}
public protocol FrameCollectorDelegate: AnyObject     {
    func didForm(event: FrameCollector.Event)
    func decompress(data: Data, isFinal: Bool) -> Data?
}
public protocol FramerEventClient: AnyObject     {
    func frameProcessed(event: FrameEvent)
}
public protocol Framer {
    func add(data: Data)
    func register(delegate: FramerEventClient)
    func createWriteFrame(opcode: FrameOpCode, payload: Data, isCompressed: Bool) -> Data
    func updateCompression(supports: Bool)
    func supportsCompression() -> Bool
}
public protocol MyWSArrayType {
}
public protocol HTTPHandlerDelegate: AnyObject     {
    func didReceiveHTTP(event: HTTPEvent)
}
public protocol HTTPHandler {
    func register(delegate: HTTPHandlerDelegate)
    func convert(request: URLRequest) -> Data
    func parse(data: Data) -> Int
}
public protocol HTTPServerDelegate: AnyObject     {
    func didReceive(event: HTTPEvent)
}
public protocol HTTPServerHandler {
    func register(delegate: HTTPServerDelegate)
    func parse(data: Data)
    func createResponse(headers: [String: String]) -> Data
}
public protocol CertificatePinning: AnyObject     {
    func evaluateTrust(trust: SecTrust, domain: String?, completion: ((PinningState) -> ()))
}
public protocol HeaderValidator: AnyObject     {
    func validate(headers: [String: String], key: String) -> Error?
}
public protocol Connection {
    func write(data: Data, opcode: FrameOpCode)
}
public protocol ConnectionDelegate: AnyObject     {
    func didReceive(event: ServerEvent)
}
public protocol Server {
    func start(address: String, port: UInt16) -> Error?
}
public protocol WebSocketClient: AnyObject     {
    func connect()
    func disconnect(closeCode: UInt16)
    func write(string: String, completion: (() -> ())?)
    func write(stringData: Data, completion: (() -> ())?)
    func write(data: Data, completion: (() -> ())?)
    func write(ping: Data, completion: (() -> ())?)
    func write(pong: Data, completion: (() -> ())?)
}
public protocol WebSocketDelegate: AnyObject     {
    func didReceive(event: WebSocketEvent, client: WebSocketClient)
}
public protocol TransportEventClient: AnyObject     {
    func connectionChanged(state: ConnectionState)
}
public protocol Transport: AnyObject     {
    func register(delegate: TransportEventClient)
    func connect(url: URL, timeout: Double, certificatePinning: CertificatePinning?)
    func disconnect()
    func write(data: Data, completion: @escaping ((Error?) -> ()))
    var usingTLS: Bool
}
public protocol ConfigSettable {
}
protocol ClientOption : CustomStringConvertible, Equatable     {
    func getSocketIOOptionValue() -> Any
}
public protocol SocketIOClientSpec : AnyObject     {
    var anyHandler: ((SocketAnyEvent) -> ())?
    var handlers: [SocketEventHandler]
    var manager: SocketManagerSpec?
    var nsp: String
    var rawEmitView: SocketRawView
    var sid: String?
    var status: SocketIOStatus
    func connect(withPayload payload: [String: Any]?)
    func connect(withPayload payload: [String: Any]?, timeoutAfter: Double, withHandler handler: (() -> ())?)
    func didConnect(toNamespace namespace: String, payload: [String: Any]?)
    func didDisconnect(reason: String)
    func didError(reason: String)
    func disconnect()
    func emit(_ event: String, _ items: SocketData..., completion: (() -> ())?)
    func emit(_ event: String, with items: [SocketData], completion: (() -> ())?)
    func emitAck(_ ack: Int, with items: [Any])
    func emitWithAck(_ event: String, _ items: SocketData...) -> OnAckCallback
    func emitWithAck(_ event: String, with items: [SocketData]) -> OnAckCallback
    func handleAck(_ ack: Int, data: [Any])
    func handleClientEvent(_ event: SocketClientEvent, data: [Any])
    func handleEvent(_ event: String, data: [Any], isInternalMessage: Bool, withAck ack: Int)
    func handlePacket(_ packet: SocketPacket)
    func leaveNamespace()
    func joinNamespace(withPayload payload: [String: Any]?)
    func off(clientEvent event: SocketClientEvent)
    func off(_ event: String)
    func off(id: UUID)
    func on(_ event: String, callback: @escaping NormalCallback) -> UUID
    func on(clientEvent event: SocketClientEvent, callback: @escaping NormalCallback) -> UUID
    func once(clientEvent event: SocketClientEvent, callback: @escaping NormalCallback) -> UUID
    func once(_ event: String, callback: @escaping NormalCallback) -> UUID
    func onAny(_ handler: @escaping (SocketAnyEvent) -> ())
    func removeAllHandlers()
    func setReconnecting(reason: String)
}
public protocol SocketEngineClient {
    func engineDidError(reason: String)
    func engineDidClose(reason: String)
    func engineDidOpen(reason: String)
    func engineDidReceivePing()
    func engineDidReceivePong()
    func engineDidSendPing()
    func engineDidSendPong()
    func parseEngineMessage(_ msg: String)
    func parseEngineBinaryData(_ data: Data)
    func engineDidWebsocketUpgrade(headers: [String: String])
}
public protocol SocketEnginePollable: SocketEngineSpec     {
    var invalidated: Bool
    var postWait: [Post]
    var session: URLSession?
    var waitingForPoll: Bool
    var waitingForPost: Bool
    func doPoll()
    func sendPollMessage(_ message: String, withType type: SocketEnginePacketType, withData datas: [Data], completion: (() -> ())?)
    func stopPolling()
}
public protocol SocketEngineSpec: AnyObject     {
    var client: SocketEngineClient?
    var closed: Bool
    var compress: Bool
    var connected: Bool
    var connectParams: [String: Any]?
    var cookies: [HTTPCookie]?
    var engineQueue: DispatchQueue
    var extraHeaders: [String: String]?
    var fastUpgrade: Bool
    var forcePolling: Bool
    var forceWebsockets: Bool
    var polling: Bool
    var probing: Bool
    var sid: String
    var socketPath: String
    var urlPolling: URL
    var urlWebSocket: URL
    var version: SocketIOVersion
    var websocket: Bool
    var ws: WebSocket?
    func connect()
    func didError(reason: String)
    func disconnect(reason: String)
    func doFastUpgrade()
    func flushWaitingForPostToWebSocket()
    func parseEngineData(_ data: Data)
    func parseEngineMessage(_ message: String)
    func write(_ msg: String, withType type: SocketEnginePacketType, withData data: [Data], completion: (() -> ())?)
}
public protocol SocketEngineWebsocket: SocketEngineSpec     {
    var wsConnected: Bool
    func sendWebSocketMessage(_ str: String,
}
public protocol SocketManagerSpec : SocketEngineClient     {
    var defaultSocket: SocketIOClient
    var engine: SocketEngineSpec?
    var forceNew: Bool
    var handleQueue: DispatchQueue
    var nsps: [String: SocketIOClient]
    var reconnects: Bool
    var reconnectWait: Int
    var reconnectWaitMax: Int
    var randomizationFactor: Double
    var socketURL: URL
    var status: SocketIOStatus
    var version: SocketIOVersion
    func connect()
    func connectSocket(_ socket: SocketIOClient, withPayload: [String: Any]?)
    func didDisconnect(reason: String)
    func disconnect()
    func disconnectSocket(_ socket: SocketIOClient)
    func disconnectSocket(forNamespace nsp: String)
    func emitAll(_ event: String, _ items: SocketData...)
    func reconnect()
    func removeSocket(_ socket: SocketIOClient) -> SocketIOClient?
    func socket(forNamespace nsp: String) -> SocketIOClient
}
public protocol SocketParsable : AnyObject     {
    func parseBinaryData(_ data: Data) -> SocketPacket?
    func parseSocketMessage(_ message: String) -> SocketPacket?
}
public protocol SocketDataBufferable : AnyObject     {
    var waitingPackets: [SocketPacket]
}
public protocol SocketLogger : AnyObject     {
    var log: Bool
    func log(_ message: @autoclosure () -> String, type: String)
    func error(_ message: @autoclosure () -> String, type: String)
}
public protocol SocketData {
    func socketRepresentation() throws -> SocketData
}

final class Anagram_GameTests: XCTestCase   {
}
final class GameModelTests: XCTestCase   {
    var gameModel: GameModel!
}
final class PhysicsGameSceneTests: XCTestCase   {
    var gameModel: GameModel!
    var scene: PhysicsGameScene!
    var testSize: CGSize!
}
final class MockTileGroupingTests: XCTestCase   {
}
class MockLetterTile {
    let letter: String
    let position: CGPoint
}
final class TileSelectionTests: XCTestCase   {
}
final class ScoringPerformanceTests: XCTestCase   {
}
final class Anagram_GameUITests: XCTestCase   {
}
final class Anagram_GameUITestsLaunchTests: XCTestCase   {
}
class AppDelegate: NSObject, UIApplicationDelegate   {
}
struct Anagram_GameApp: App   {
}
class GameModel: ObservableObject   {
    var currentSentence: String
    var scrambledLetters: [String]
    var gameState: GameState
    var wordsCompleted: Int
    var customPhraseInfo: String
    weak var messageTileSpawner: MessageTileSpawner?
    var currentPhraseId: String?
    var currentHints: [String]
    var currentScore: Int
    var hintsUsed: Int
    var phraseDifficulty: Int
    var playerId: String?
    var playerName: String?
    var networkManager: NetworkManager?
    var currentCustomPhrase: CustomPhrase?
}
final class Item {
    var timestamp: Date
}
struct Player: Codable, Identifiable, Equatable   {
    let id: String
    let name: String
    let lastSeen: Date
    let isActive: Bool
    let phrasesCompleted: Int
}
struct CustomPhrase: Codable, Identifiable, Equatable   {
    let id: String
    let content: String
    let senderId: String
    let targetId: String
    let createdAt: Date
    let isConsumed: Bool
    let senderName: String
    let language: String // Language code for LanguageTile feature
}
struct HintStatus: Codable   {
    let hintsUsed: [UsedHint]
    let nextHintLevel: Int?
    let hintsRemaining: Int
    let currentScore: Int
    let nextHintScore: Int?
    let canUseNextHint: Bool
}
struct ScorePreview: Codable   {
    let noHints: Int
    let level1: Int
    let level2: Int
    let level3: Int
}
struct HintResponse: Codable   {
    let success: Bool
    let hint: HintData
    let scorePreview: ScorePreview
    let timestamp: String
}
struct PhrasePreview: Codable   {
    let success: Bool
    let phrase: PhraseData
    let timestamp: String
}
struct CompletionResult: Codable   {
    let success: Bool
    let completion: CompletionData
    let timestamp: String
}
private struct RegistrationRequestBody: Encodable   {
    let name: String
}
class NetworkManager: ObservableObject   {
    var connectionStatus: ConnectionStatus
    var isConnected: Bool
    var currentPlayer: Player?
    var onlinePlayers: [Player]
    var lastReceivedPhrase: CustomPhrase?
    var hasNewPhrase: Bool
    var justReceivedPhrase: CustomPhrase?
}
public struct DifficultyAnalysis: Codable   {
    let phrase: String
    let language: String
    let score: Double
    let difficulty: String
    let timestamp: String
}
public struct PlayerStats: Codable   {
    let dailyScore: Int
    let dailyRank: Int
    let weeklyScore: Int
    let weeklyRank: Int
    let totalScore: Int
    let totalRank: Int
    let totalPhrases: Int
}
public struct LeaderboardEntry: Codable   {
    let rank: Int
    let playerName: String
    let totalScore: Int
    let phrasesCompleted: Int
}
struct TimeoutError: Error   {
}
struct HintButton: View   {
    let phraseId: String
    let onHintUsed: (String) -> Void
}
struct LobbyView: View   {
    var gameModel: GameModel
}
struct StatCard: View   {
    let title: String
    let value: String
    let rank: String
}
struct LeaderboardRow: View   {
    let rank: Int
    let playerName: String
    let score: Int
    let phrasesCompleted: Int
    let isCurrentPlayer: Bool
}
struct OnlinePlayersView: View   {
}
struct PlayerRowView: View   {
    let player: Player
    let isCurrentPlayer: Bool
}
struct PhraseCreationView: View   {
    var isPresented: Bool
}
struct PhraseCreationView_Previews: PreviewProvider   {
}
struct HintButtonView: View   {
    let phraseId: String
    let gameModel: GameModel
    let gameScene: PhysicsGameScene?
    let onHintUsed: (String) -> Void
}
struct PhysicsCategories {
    static let tile: UInt32
    static let shelf: UInt32
    static let floor: UInt32
    static let wall: UInt32
}
struct PhysicsGameView: View   {
    var gameModel: GameModel
    var showingGame: Bool
}
class PhysicsGameScene: SKScene, MessageTileSpawner   {
    var motionManager: CMMotionManager?
    var onCelebration: ((String) -> Void)?
    var celebrationText: String
}
class LetterTile: SKSpriteNode   {
    let letter: String
}
class ScoreTile: SKSpriteNode   {
}
class MessageTile: SKSpriteNode   {
}
class LanguageTile: SKSpriteNode   {
    var currentLanguage: String
}
struct SpriteKitView: UIViewRepresentable   {
    let scene: SKScene
}
struct PlayerRegistrationView: View   {
    var isPresented: Bool
}
private class ResourceBundleClass {
}
private class BundleFinder {
}
public class WSCompression: CompressionHandler   {
    var decompressor: Decompressor?
    var compressor: Compressor?
}
class Decompressor {
}
class Compressor {
}
struct ByteError: Swift.Error   {
}
public class NativeEngine: NSObject, Engine, URLSessionDataDelegate, URLSessionWebSocketDelegate   {
    weak var delegate: EngineDelegate?
}
public class FoundationHTTPHandler: HTTPHandler   {
    weak var delegate: HTTPHandlerDelegate?
}
public class FoundationHTTPServerHandler: HTTPServerHandler   {
    weak var delegate: HTTPServerDelegate?
    let getVerb: NSString
}
public class FrameCollector {
    weak var delegate: FrameCollectorDelegate?
}
public enum CloseCode: UInt16   {
}
public enum FrameOpCode: UInt8   {
}
public struct Frame {
    let isFin: Bool
    let needsDecompression: Bool
    let isMasked: Bool
    let opcode: FrameOpCode
    let payloadLength: UInt64
    let payload: Data
    let closeCode: UInt16 //only used by connectionClose opcode
}
public enum FrameEvent {
}
public class WSFramer: Framer   {
}
public enum HTTPUpgradeError: Error   {
}
public struct HTTPWSHeader {
}
public enum HTTPEvent {
}
public struct URLParts {
    let port: Int
    let host: String
    let isTLS: Bool
}
public class StringHTTPHandler: HTTPHandler   {
    weak var delegate: HTTPHandlerDelegate?
}
public enum FoundationSecurityError: Error   {
}
public class FoundationSecurity {
}
public enum SecurityErrorCode: UInt16   {
}
public enum PinningState {
}
public enum ConnectionEvent {
}
public enum ServerEvent {
}
public class WebSocketServer: Server, ConnectionDelegate   {
    public var onEvent: ((ServerEvent) -> Void)?
}
public class ServerConnection: Connection, HTTPServerDelegate, FramerEventClient, FrameCollectorDelegate, TransportEventClient   {
    let transport: TCPTransport
    public var onEvent: ((ConnectionEvent) -> Void)?
    public weak var delegate: ConnectionDelegate?
}
public enum ErrorType: Error   {
}
public struct WSError: Error   {
    public let type: ErrorType
    public let message: String
    public let code: UInt16
}
public enum WebSocketEvent {
}
open class WebSocket: WebSocketClient, EngineDelegate   {
    public weak var delegate: WebSocketDelegate?
    public var onEvent: ((WebSocketEvent) -> Void)?
    public var request: URLRequest
}
public enum FoundationTransportError: Error   {
}
public class FoundationTransport: NSObject, Transport, StreamDelegate   {
}
public enum TCPTransportError: Error   {
}
public class TCPTransport: Transport   {
}
public enum ConnectionState {
}
class CompressionTests: XCTestCase   {
}
class FuzzingTests: XCTestCase   {
    var websocket: WebSocket!
    var server: MockServer!
}
public class MockConnection: Connection, HTTPServerDelegate, FramerEventClient, FrameCollectorDelegate   {
    let transport: MockTransport
    public var onEvent: ((ConnectionEvent) -> Void)?
}
public class MockServer: Server, ConnectionDelegate   {
    public var onEvent: ((ServerEvent) -> Void)?
}
public class MockTransport: Transport   {
    weak var server: MockServer?
}
public class MockSecurity: CertificatePinning, HeaderValidator   {
}
class StarscreamTests: XCTestCase   {
}
class AppDelegate: UIResponder, UIApplicationDelegate   {
    var window: UIWindow?
}
class ViewController: UIViewController   {
}
class AppDelegate: UIResponder, UIApplicationDelegate   {
    var window: UIWindow?
}
class ViewController: UIViewController, WebSocketDelegate   {
    var socket: WebSocket!
}
class AppDelegate: UIResponder, UIApplicationDelegate   {
    var window: UIWindow?
}
class ViewController: UIViewController, WebSocketDelegate   {
    var socket: WebSocket
}
public final class SocketAckEmitter: NSObject   {
}
public final class OnAckCallback: NSObject   {
}
public enum SocketAckStatus : String   {
}
private struct SocketAck : Hashable   {
    let ack: Int
    var callback: AckCallback!
}
class SocketAckManager {
}
public final class SocketAnyEvent : NSObject   {
    public let event: String
    public let items: [Any]?
}
public struct SocketEventHandler {
    public let event: String
    public let id: UUID
    public let callback: NormalCallback
}
open class SocketIOClient: NSObject, SocketIOClientSpec   {
    public let nsp: String
    var connectPayload: [String: Any]?
    func emit(_ data: [Any],
    open func reconnect()
}
public struct SocketIOClientConfiguration : ExpressibleByArrayLiteral, Collection, MutableCollection   {
}
public enum SocketIOVersion: Int   {
}
public enum SocketIOClientOption : ClientOption   {
}
public enum SocketClientEvent : String   {
}
public enum SocketIOStatus : Int, CustomStringConvertible   {
}
public final class SocketRawView : NSObject   {
}
public final class SocketRawAckView : NSObject   {
}
enum EngineError: Error   {
}
public enum SocketEnginePacketType: Int   {
}
open class SocketManager: NSObject, SocketManagerSpec, SocketParsable, SocketDataBufferable, ConfigSettable   {
    public let socketURL: URL
    public var engine: SocketEngineSpec?
}
public struct SocketPacket : CustomStringConvertible   {
    public let nsp: String
    public let id: Int
    public let type: PacketType
}
enum PacketType: Int   {
}
public enum SocketParsableError : Error   {
}
enum JSONError : Error   {
}
class DefaultSocketLogger : SocketLogger   {
    static var Logger: SocketLogger
}
struct SocketStringReader {
    let message: String
    var currentIndex: String.UTF16View.Index
}
enum Either<E, V> {
}
class SocketAckManagerTest : XCTestCase   {
}
class SocketBasicPacketTest : XCTestCase   {
    var parser: SocketParsable!
}
class SocketEngineTest: XCTestCase   {
    var manager: SocketManager!
    var socket: SocketIOClient!
    var engine: SocketEngine!
}
class TestSocketIOClientConfiguration : XCTestCase   {
}
class SocketMangerTest : XCTestCase   {
}
public enum ManagerExpectation: String   {
}
public class TestManager: SocketManager   {
}
public class TestSocket: SocketIOClient   {
}
class SocketNamespacePacketTest : XCTestCase   {
    var parser: SocketParsable!
}
class SocketParserTest: XCTestCase   {
    static let packetTypes: [String: (String, [Any], [Data], Int)]
}
class SocketSideEffectTest: XCTestCase   {
}
struct ThrowingData: SocketData   {
}
class TestEngine: SocketEngineSpec   {
    weak var client: SocketEngineClient?
    var connectParams: [String: Any]?
    var extraHeaders: [String: String]?
    internal var onConnect: (() -> ())?
    func didError(reason: String)
    func disconnect(reason: String)
    func doFastUpgrade()
    func flushWaitingForPostToWebSocket()
    func parseEngineData(_ data: Data)
    func parseEngineMessage(_ message: String)
    func write(_ msg: String, withType type: SocketEnginePacketType, withData data: [Data], completion: (() -> ())?)
}
public class OBjcUtils: NSObject   {
}
final class Anagram_GameTests: XCTestCase    {
}
final class GameModelTests: XCTestCase    {
    var gameModel: GameModel!
}
final class PhysicsGameSceneTests: XCTestCase    {
    var gameModel: GameModel!
    var scene: PhysicsGameScene!
    var testSize: CGSize!
}
final class MockTileGroupingTests: XCTestCase    {
}
class MockLetterTile {
    let letter: String
    let position: CGPoint
}
final class TileSelectionTests: XCTestCase    {
}
final class ScoringPerformanceTests: XCTestCase    {
}
final class Anagram_GameUITests: XCTestCase    {
}
final class Anagram_GameUITestsLaunchTests: XCTestCase    {
}
class AppDelegate: NSObject, UIApplicationDelegate    {
}
struct Anagram_GameApp: App    {
}
class GameModel: ObservableObject    {
    var currentSentence: String
    var scrambledLetters: [String]
    var gameState: GameState
    var wordsCompleted: Int
    var customPhraseInfo: String
    var isShowingPhraseNotification: Bool
    var currentPhraseId: String?
    var currentHints: [String]
    var currentScore: Int
    var hintsUsed: Int
    var phraseDifficulty: Int
    var playerId: String?
    var playerName: String?
    var networkManager: NetworkManager?
    var currentCustomPhrase: CustomPhrase?
}
final class Item {
    var timestamp: Date
}
struct Player: Codable, Identifiable, Equatable    {
    let id: String
    let name: String
    let lastSeen: Date
    let isActive: Bool
    let phrasesCompleted: Int
}
struct CustomPhrase: Codable, Identifiable, Equatable    {
    let id: String
    let content: String
    let senderId: String
    let targetId: String
    let createdAt: Date
    let isConsumed: Bool
    let senderName: String
    let language: String // Language code for LanguageTile feature
}
struct HintStatus: Codable    {
    let hintsUsed: [UsedHint]
    let nextHintLevel: Int?
    let hintsRemaining: Int
    let currentScore: Int
    let nextHintScore: Int?
    let canUseNextHint: Bool
}
struct ScorePreview: Codable    {
    let noHints: Int
    let level1: Int
    let level2: Int
    let level3: Int
}
struct HintResponse: Codable    {
    let success: Bool
    let hint: HintData
    let scorePreview: ScorePreview
    let timestamp: String
}
struct PhrasePreview: Codable    {
    let success: Bool
    let phrase: PhraseData
    let timestamp: String
}
struct CompletionResult: Codable    {
    let success: Bool
    let completion: CompletionData
    let timestamp: String
}
private struct RegistrationRequestBody: Encodable    {
    let name: String
}
class NetworkManager: ObservableObject    {
    var connectionStatus: ConnectionStatus
    var isConnected: Bool
    var currentPlayer: Player?
    var onlinePlayers: [Player]
    var lastReceivedPhrase: CustomPhrase?
    var hasNewPhrase: Bool
    var justReceivedPhrase: CustomPhrase?
}
public struct DifficultyAnalysis: Codable    {
    let phrase: String
    let language: String
    let score: Double
    let difficulty: String
    let timestamp: String
}
public struct PlayerStats: Codable    {
    let dailyScore: Int
    let dailyRank: Int
    let weeklyScore: Int
    let weeklyRank: Int
    let totalScore: Int
    let totalRank: Int
    let totalPhrases: Int
}
public struct LeaderboardEntry: Codable    {
    let rank: Int
    let playerName: String
    let totalScore: Int
    let phrasesCompleted: Int
}
struct TimeoutError: Error    {
}
struct HintButton: View    {
    let phraseId: String
    let onHintUsed: (String) -> Void
}
struct LobbyView: View    {
    var gameModel: GameModel
}
struct StatCard: View    {
    let title: String
    let value: String
    let rank: String
}
struct LeaderboardRow: View    {
    let rank: Int
    let playerName: String
    let score: Int
    let phrasesCompleted: Int
    let isCurrentPlayer: Bool
}
struct OnlinePlayersView: View    {
}
struct PlayerRowView: View    {
    let player: Player
    let isCurrentPlayer: Bool
}
struct PhraseCreationView: View    {
    var isPresented: Bool
}
struct PhraseCreationView_Previews: PreviewProvider    {
}
struct HintButtonView: View    {
    let phraseId: String
    let gameModel: GameModel
    let gameScene: PhysicsGameScene?
    let onHintUsed: (String) -> Void
}
struct PhysicsCategories {
    static let tile: UInt32
    static let shelf: UInt32
    static let floor: UInt32
    static let wall: UInt32
}
struct PhysicsGameView: View    {
    var gameModel: GameModel
    var showingGame: Bool
}
class PhysicsGameScene: SKScene    {
    var motionManager: CMMotionManager?
    var onCelebration: ((String) -> Void)?
    var celebrationText: String
}
class LetterTile: SKSpriteNode    {
    let letter: String
}
class ScoreTile: SKSpriteNode    {
}
class LanguageTile: SKSpriteNode    {
    var currentLanguage: String
}
struct SpriteKitView: UIViewRepresentable    {
    let scene: SKScene
}
struct PlayerRegistrationView: View    {
    var isPresented: Bool
}
private class ResourceBundleClass {
}
private class BundleFinder {
}
public class WSCompression: CompressionHandler    {
    var decompressor: Decompressor?
    var compressor: Compressor?
}
class Decompressor {
}
class Compressor {
}
struct ByteError: Swift.Error    {
}
public class NativeEngine: NSObject, Engine, URLSessionDataDelegate, URLSessionWebSocketDelegate    {
    weak var delegate: EngineDelegate?
}
public class FoundationHTTPHandler: HTTPHandler    {
    weak var delegate: HTTPHandlerDelegate?
}
public class FoundationHTTPServerHandler: HTTPServerHandler    {
    weak var delegate: HTTPServerDelegate?
    let getVerb: NSString
}
public class FrameCollector {
    weak var delegate: FrameCollectorDelegate?
}
public enum CloseCode: UInt16    {
}
public enum FrameOpCode: UInt8    {
}
public struct Frame {
    let isFin: Bool
    let needsDecompression: Bool
    let isMasked: Bool
    let opcode: FrameOpCode
    let payloadLength: UInt64
    let payload: Data
    let closeCode: UInt16 //only used by connectionClose opcode
}
public enum FrameEvent {
}
public class WSFramer: Framer    {
}
public enum HTTPUpgradeError: Error    {
}
public struct HTTPWSHeader {
}
public enum HTTPEvent {
}
public struct URLParts {
    let port: Int
    let host: String
    let isTLS: Bool
}
public class StringHTTPHandler: HTTPHandler    {
    weak var delegate: HTTPHandlerDelegate?
}
public enum FoundationSecurityError: Error    {
}
public class FoundationSecurity {
}
public enum SecurityErrorCode: UInt16    {
}
public enum PinningState {
}
public enum ConnectionEvent {
}
public enum ServerEvent {
}
public class WebSocketServer: Server, ConnectionDelegate    {
    public var onEvent: ((ServerEvent) -> Void)?
}
public class ServerConnection: Connection, HTTPServerDelegate, FramerEventClient, FrameCollectorDelegate, TransportEventClient    {
    let transport: TCPTransport
    public var onEvent: ((ConnectionEvent) -> Void)?
    public weak var delegate: ConnectionDelegate?
}
public enum ErrorType: Error    {
}
public struct WSError: Error    {
    public let type: ErrorType
    public let message: String
    public let code: UInt16
}
public enum WebSocketEvent {
}
open class WebSocket: WebSocketClient, EngineDelegate    {
    public weak var delegate: WebSocketDelegate?
    public var onEvent: ((WebSocketEvent) -> Void)?
    public var request: URLRequest
}
public enum FoundationTransportError: Error    {
}
public class FoundationTransport: NSObject, Transport, StreamDelegate    {
}
public enum TCPTransportError: Error    {
}
public class TCPTransport: Transport    {
}
public enum ConnectionState {
}
class CompressionTests: XCTestCase    {
}
class FuzzingTests: XCTestCase    {
    var websocket: WebSocket!
    var server: MockServer!
}
public class MockConnection: Connection, HTTPServerDelegate, FramerEventClient, FrameCollectorDelegate    {
    let transport: MockTransport
    public var onEvent: ((ConnectionEvent) -> Void)?
}
public class MockServer: Server, ConnectionDelegate    {
    public var onEvent: ((ServerEvent) -> Void)?
}
public class MockTransport: Transport    {
    weak var server: MockServer?
}
public class MockSecurity: CertificatePinning, HeaderValidator    {
}
class StarscreamTests: XCTestCase    {
}
class AppDelegate: UIResponder, UIApplicationDelegate    {
    var window: UIWindow?
}
class ViewController: UIViewController    {
}
class AppDelegate: UIResponder, UIApplicationDelegate    {
    var window: UIWindow?
}
class ViewController: UIViewController, WebSocketDelegate    {
    var socket: WebSocket!
}
class AppDelegate: UIResponder, UIApplicationDelegate    {
    var window: UIWindow?
}
class ViewController: UIViewController, WebSocketDelegate    {
    var socket: WebSocket
}
public final class SocketAckEmitter: NSObject    {
}
public final class OnAckCallback: NSObject    {
}
public enum SocketAckStatus : String    {
}
private struct SocketAck : Hashable    {
    let ack: Int
    var callback: AckCallback!
}
class SocketAckManager {
}
public final class SocketAnyEvent : NSObject    {
    public let event: String
    public let items: [Any]?
}
public struct SocketEventHandler {
    public let event: String
    public let id: UUID
    public let callback: NormalCallback
}
open class SocketIOClient: NSObject, SocketIOClientSpec    {
    public let nsp: String
    var connectPayload: [String: Any]?
    func emit(_ data: [Any],
    open func reconnect()
}
public struct SocketIOClientConfiguration : ExpressibleByArrayLiteral, Collection, MutableCollection    {
}
public enum SocketIOVersion: Int    {
}
public enum SocketIOClientOption : ClientOption    {
}
public enum SocketClientEvent : String    {
}
public enum SocketIOStatus : Int, CustomStringConvertible    {
}
public final class SocketRawView : NSObject    {
}
public final class SocketRawAckView : NSObject    {
}
enum EngineError: Error    {
}
public enum SocketEnginePacketType: Int    {
}
open class SocketManager: NSObject, SocketManagerSpec, SocketParsable, SocketDataBufferable, ConfigSettable    {
    public let socketURL: URL
    public var engine: SocketEngineSpec?
}
public struct SocketPacket : CustomStringConvertible    {
    public let nsp: String
    public let id: Int
    public let type: PacketType
}
enum PacketType: Int    {
}
public enum SocketParsableError : Error    {
}
enum JSONError : Error    {
}
class DefaultSocketLogger : SocketLogger    {
    static var Logger: SocketLogger
}
struct SocketStringReader {
    let message: String
    var currentIndex: String.UTF16View.Index
}
enum Either<E, V> {
}
class SocketAckManagerTest : XCTestCase    {
}
class SocketBasicPacketTest : XCTestCase    {
    var parser: SocketParsable!
}
class SocketEngineTest: XCTestCase    {
    var manager: SocketManager!
    var socket: SocketIOClient!
    var engine: SocketEngine!
}
class TestSocketIOClientConfiguration : XCTestCase    {
}
class SocketMangerTest : XCTestCase    {
}
public enum ManagerExpectation: String    {
}
public class TestManager: SocketManager    {
}
public class TestSocket: SocketIOClient    {
}
class SocketNamespacePacketTest : XCTestCase    {
    var parser: SocketParsable!
}
class SocketParserTest: XCTestCase    {
    static let packetTypes: [String: (String, [Any], [Data], Int)]
}
class SocketSideEffectTest: XCTestCase    {
}
struct ThrowingData: SocketData    {
}
class TestEngine: SocketEngineSpec    {
    weak var client: SocketEngineClient?
    var connectParams: [String: Any]?
    var extraHeaders: [String: String]?
    internal var onConnect: (() -> ())?
    func didError(reason: String)
    func disconnect(reason: String)
    func doFastUpgrade()
    func flushWaitingForPostToWebSocket()
    func parseEngineData(_ data: Data)
    func parseEngineMessage(_ message: String)
    func write(_ msg: String, withType type: SocketEnginePacketType, withData data: [Data], completion: (() -> ())?)
}
public class OBjcUtils: NSObject    {
}
final class Anagram_GameTests: XCTestCase     {
}
final class GameModelTests: XCTestCase     {
    var gameModel: GameModel!
}
final class PhysicsGameSceneTests: XCTestCase     {
    var gameModel: GameModel!
    var scene: PhysicsGameScene!
    var testSize: CGSize!
}
final class MockTileGroupingTests: XCTestCase     {
}
class MockLetterTile {
    let letter: String
    let position: CGPoint
}
final class TileSelectionTests: XCTestCase     {
}
final class ScoringPerformanceTests: XCTestCase     {
}
final class Anagram_GameUITests: XCTestCase     {
}
final class Anagram_GameUITestsLaunchTests: XCTestCase     {
}
class AppDelegate: NSObject, UIApplicationDelegate     {
}
struct Anagram_GameApp: App     {
}
class GameModel: ObservableObject     {
    var currentSentence: String
    var scrambledLetters: [String]
    var gameState: GameState
    var wordsCompleted: Int
    var customPhraseInfo: String
    var isShowingPhraseNotification: Bool
    var currentPhraseId: String?
    var currentHints: [String]
    var currentScore: Int
    var hintsUsed: Int
    var phraseDifficulty: Int
    var playerId: String?
    var playerName: String?
    var networkManager: NetworkManager?
    var currentCustomPhrase: CustomPhrase?
}
final class Item {
    var timestamp: Date
}
struct Player: Codable, Identifiable, Equatable     {
    let id: String
    let name: String
    let lastSeen: Date
    let isActive: Bool
    let phrasesCompleted: Int
}
struct CustomPhrase: Codable, Identifiable, Equatable     {
    let id: String
    let content: String
    let senderId: String
    let targetId: String
    let createdAt: Date
    let isConsumed: Bool
    let senderName: String
    let language: String // Language code for LanguageTile feature
}
struct HintStatus: Codable     {
    let hintsUsed: [UsedHint]
    let nextHintLevel: Int?
    let hintsRemaining: Int
    let currentScore: Int
    let nextHintScore: Int?
    let canUseNextHint: Bool
}
struct ScorePreview: Codable     {
    let noHints: Int
    let level1: Int
    let level2: Int
    let level3: Int
}
struct HintResponse: Codable     {
    let success: Bool
    let hint: HintData
    let scorePreview: ScorePreview
    let timestamp: String
}
struct PhrasePreview: Codable     {
    let success: Bool
    let phrase: PhraseData
    let timestamp: String
}
struct CompletionResult: Codable     {
    let success: Bool
    let completion: CompletionData
    let timestamp: String
}
private struct RegistrationRequestBody: Encodable     {
    let name: String
}
class NetworkManager: ObservableObject     {
    var connectionStatus: ConnectionStatus
    var isConnected: Bool
    var currentPlayer: Player?
    var onlinePlayers: [Player]
    var lastReceivedPhrase: CustomPhrase?
    var hasNewPhrase: Bool
    var justReceivedPhrase: CustomPhrase?
}
public struct DifficultyAnalysis: Codable     {
    let phrase: String
    let language: String
    let score: Double
    let difficulty: String
    let timestamp: String
}
public struct PlayerStats: Codable     {
    let dailyScore: Int
    let dailyRank: Int
    let weeklyScore: Int
    let weeklyRank: Int
    let totalScore: Int
    let totalRank: Int
    let totalPhrases: Int
}
public struct LeaderboardEntry: Codable     {
    let rank: Int
    let playerName: String
    let totalScore: Int
    let phrasesCompleted: Int
}
struct TimeoutError: Error     {
}
struct HintButton: View     {
    let phraseId: String
    let onHintUsed: (String) -> Void
}
struct LobbyView: View     {
    var gameModel: GameModel
}
struct StatCard: View     {
    let title: String
    let value: String
    let rank: String
}
struct LeaderboardRow: View     {
    let rank: Int
    let playerName: String
    let score: Int
    let phrasesCompleted: Int
    let isCurrentPlayer: Bool
}
struct OnlinePlayersView: View     {
}
struct PlayerRowView: View     {
    let player: Player
    let isCurrentPlayer: Bool
}
struct PhraseCreationView: View     {
    var isPresented: Bool
}
struct PhraseCreationView_Previews: PreviewProvider     {
}
struct HintButtonView: View     {
    let phraseId: String
    let gameModel: GameModel
    let gameScene: PhysicsGameScene?
    let onHintUsed: (String) -> Void
}
struct PhysicsCategories {
    static let tile: UInt32
    static let shelf: UInt32
    static let floor: UInt32
    static let wall: UInt32
}
struct PhysicsGameView: View     {
    var gameModel: GameModel
    var showingGame: Bool
}
class PhysicsGameScene: SKScene     {
    var motionManager: CMMotionManager?
    var onCelebration: ((String) -> Void)?
    var celebrationText: String
}
class LetterTile: SKSpriteNode     {
    let letter: String
}
class ScoreTile: SKSpriteNode     {
}
class LanguageTile: SKSpriteNode     {
    var currentLanguage: String
}
struct SpriteKitView: UIViewRepresentable     {
    let scene: SKScene
}
struct PlayerRegistrationView: View     {
    var isPresented: Bool
}
private class ResourceBundleClass {
}
private class BundleFinder {
}
public class WSCompression: CompressionHandler     {
    var decompressor: Decompressor?
    var compressor: Compressor?
}
class Decompressor {
}
class Compressor {
}
struct ByteError: Swift.Error     {
}
public class NativeEngine: NSObject, Engine, URLSessionDataDelegate, URLSessionWebSocketDelegate     {
    weak var delegate: EngineDelegate?
}
public class FoundationHTTPHandler: HTTPHandler     {
    weak var delegate: HTTPHandlerDelegate?
}
public class FoundationHTTPServerHandler: HTTPServerHandler     {
    weak var delegate: HTTPServerDelegate?
    let getVerb: NSString
}
public class FrameCollector {
    weak var delegate: FrameCollectorDelegate?
}
public enum CloseCode: UInt16     {
}
public enum FrameOpCode: UInt8     {
}
public struct Frame {
    let isFin: Bool
    let needsDecompression: Bool
    let isMasked: Bool
    let opcode: FrameOpCode
    let payloadLength: UInt64
    let payload: Data
    let closeCode: UInt16 //only used by connectionClose opcode
}
public enum FrameEvent {
}
public class WSFramer: Framer     {
}
public enum HTTPUpgradeError: Error     {
}
public struct HTTPWSHeader {
}
public enum HTTPEvent {
}
public struct URLParts {
    let port: Int
    let host: String
    let isTLS: Bool
}
public class StringHTTPHandler: HTTPHandler     {
    weak var delegate: HTTPHandlerDelegate?
}
public enum FoundationSecurityError: Error     {
}
public class FoundationSecurity {
}
public enum SecurityErrorCode: UInt16     {
}
public enum PinningState {
}
public enum ConnectionEvent {
}
public enum ServerEvent {
}
public class WebSocketServer: Server, ConnectionDelegate     {
    public var onEvent: ((ServerEvent) -> Void)?
}
public class ServerConnection: Connection, HTTPServerDelegate, FramerEventClient, FrameCollectorDelegate, TransportEventClient     {
    let transport: TCPTransport
    public var onEvent: ((ConnectionEvent) -> Void)?
    public weak var delegate: ConnectionDelegate?
}
public enum ErrorType: Error     {
}
public struct WSError: Error     {
    public let type: ErrorType
    public let message: String
    public let code: UInt16
}
public enum WebSocketEvent {
}
open class WebSocket: WebSocketClient, EngineDelegate     {
    public weak var delegate: WebSocketDelegate?
    public var onEvent: ((WebSocketEvent) -> Void)?
    public var request: URLRequest
}
public enum FoundationTransportError: Error     {
}
public class FoundationTransport: NSObject, Transport, StreamDelegate     {
}
public enum TCPTransportError: Error     {
}
public class TCPTransport: Transport     {
}
public enum ConnectionState {
}
class CompressionTests: XCTestCase     {
}
class FuzzingTests: XCTestCase     {
    var websocket: WebSocket!
    var server: MockServer!
}
public class MockConnection: Connection, HTTPServerDelegate, FramerEventClient, FrameCollectorDelegate     {
    let transport: MockTransport
    public var onEvent: ((ConnectionEvent) -> Void)?
}
public class MockServer: Server, ConnectionDelegate     {
    public var onEvent: ((ServerEvent) -> Void)?
}
public class MockTransport: Transport     {
    weak var server: MockServer?
}
public class MockSecurity: CertificatePinning, HeaderValidator     {
}
class StarscreamTests: XCTestCase     {
}
class AppDelegate: UIResponder, UIApplicationDelegate     {
    var window: UIWindow?
}
class ViewController: UIViewController     {
}
class AppDelegate: UIResponder, UIApplicationDelegate     {
    var window: UIWindow?
}
class ViewController: UIViewController, WebSocketDelegate     {
    var socket: WebSocket!
}
class AppDelegate: UIResponder, UIApplicationDelegate     {
    var window: UIWindow?
}
class ViewController: UIViewController, WebSocketDelegate     {
    var socket: WebSocket
}
public final class SocketAckEmitter: NSObject     {
}
public final class OnAckCallback: NSObject     {
}
public enum SocketAckStatus : String     {
}
private struct SocketAck : Hashable     {
    let ack: Int
    var callback: AckCallback!
}
class SocketAckManager {
}
public final class SocketAnyEvent : NSObject     {
    public let event: String
    public let items: [Any]?
}
public struct SocketEventHandler {
    public let event: String
    public let id: UUID
    public let callback: NormalCallback
}
open class SocketIOClient: NSObject, SocketIOClientSpec     {
    public let nsp: String
    var connectPayload: [String: Any]?
    func emit(_ data: [Any],
    open func reconnect()
}
public struct SocketIOClientConfiguration : ExpressibleByArrayLiteral, Collection, MutableCollection     {
}
public enum SocketIOVersion: Int     {
}
public enum SocketIOClientOption : ClientOption     {
}
public enum SocketClientEvent : String     {
}
public enum SocketIOStatus : Int, CustomStringConvertible     {
}
public final class SocketRawView : NSObject     {
}
public final class SocketRawAckView : NSObject     {
}
enum EngineError: Error     {
}
public enum SocketEnginePacketType: Int     {
}
open class SocketManager: NSObject, SocketManagerSpec, SocketParsable, SocketDataBufferable, ConfigSettable     {
    public let socketURL: URL
    public var engine: SocketEngineSpec?
}
public struct SocketPacket : CustomStringConvertible     {
    public let nsp: String
    public let id: Int
    public let type: PacketType
}
enum PacketType: Int     {
}
public enum SocketParsableError : Error     {
}
enum JSONError : Error     {
}
class DefaultSocketLogger : SocketLogger     {
    static var Logger: SocketLogger
}
struct SocketStringReader {
    let message: String
    var currentIndex: String.UTF16View.Index
}
enum Either<E, V> {
}
class SocketAckManagerTest : XCTestCase     {
}
class SocketBasicPacketTest : XCTestCase     {
    var parser: SocketParsable!
}
class SocketEngineTest: XCTestCase     {
    var manager: SocketManager!
    var socket: SocketIOClient!
    var engine: SocketEngine!
}
class TestSocketIOClientConfiguration : XCTestCase     {
}
class SocketMangerTest : XCTestCase     {
}
public enum ManagerExpectation: String     {
}
public class TestManager: SocketManager     {
}
public class TestSocket: SocketIOClient     {
}
class SocketNamespacePacketTest : XCTestCase     {
    var parser: SocketParsable!
}
class SocketParserTest: XCTestCase     {
    static let packetTypes: [String: (String, [Any], [Data], Int)]
}
class SocketSideEffectTest: XCTestCase     {
}
struct ThrowingData: SocketData     {
}
class TestEngine: SocketEngineSpec     {
    weak var client: SocketEngineClient?
    var connectParams: [String: Any]?
    var extraHeaders: [String: String]?
    internal var onConnect: (() -> ())?
    func didError(reason: String)
    func disconnect(reason: String)
    func doFastUpgrade()
    func flushWaitingForPostToWebSocket()
    func parseEngineData(_ data: Data)
    func parseEngineMessage(_ message: String)
    func write(_ msg: String, withType type: SocketEnginePacketType, withData data: [Data], completion: (() -> ())?)
}
public class OBjcUtils: NSObject     {
}

func groupTilesByProximity(tiles: [MockLetterTile], radius: CGFloat) -> [[MockLetterTile]]
func validateWordsMatch(target: [String], found: [String]) -> Bool
static func == (lhs: MockLetterTile, rhs: MockLetterTile) -> Bool
func hash(into hasher: inout Hasher)
func findBestTileCombination(for targetLetters: [Character], from allTiles: [MockLetterTile], excluding usedTiles: Set<MockLetterTile>) -> [MockLetterTile]?
func generateTileCombinations(for targetLetters: [Character], from tilesByLetter: [Character: [MockLetterTile]]) -> [[MockLetterTile]]
func generateCombinations(remainingLetters: [Character], currentCombination: [MockLetterTile], usedTiles: Set<MockLetterTile>) -> [[MockLetterTile]]
func startNewGame(isUserInitiated: Bool = false) async
func resetGame()
func validateWordCompletion(formedWords: [String]) -> Bool
func checkWordFromTiles(at positions: [CGPoint]) -> String?
func getExpectedWords() -> [String]
func completeGame()
func skipCurrentGame() async
func addHint(_ hint: String)
func refreshPhrasesForLobby() async
func connect(playerId: String)
func disconnect()
func registerPlayer(name: String) async -> Bool
func fetchOnlinePlayers() async
func sendPhrase(content: String, targetId: String, clue: String? = nil, language: String = "en") async -> Bool
func fetchPhrasesForCurrentPlayer() async -> [CustomPhrase]
func consumePhrase(phraseId: String) async -> Bool
func skipPhrase(phraseId: String) async -> Bool
func getPhrasePreview(phraseId: String) async -> PhrasePreview?
func useHint(phraseId: String, level: Int) async -> HintResponse?
func getHintStatus(phraseId: String) async -> HintStatus?
func completePhrase(phraseId: String, completionTime: Int = 0) async -> CompletionResult?
func startPeriodicPlayerListFetch()
func stopPeriodicPlayerListFetch()
func getPlayerStats(playerId: String) async throws -> PlayerStats
func getLeaderboard(period: String, limit: Int = 10) async throws -> [LeaderboardEntry]
func getOnlinePlayersCount() async throws -> Int
func testConnection() async -> Result<Bool, NetworkError>
func connect()
func sendManualPing()
func analyzeDifficulty(phrase: String, language: String = "en") async -> DifficultyAnalysis?
func withTimeout<T>(seconds: TimeInterval, operation: @escaping () async throws -> T) async throws -> T
func updateScoreTile()
func updateLanguageTile()
func spawnMessageTile(message: String)
func updateGravity(from gravity: CMAcceleration)
func triggerQuake()
func triggerQuickQuake()
func triggerHint()
func showHint1()
func showHint2()
func showHint3()
func resetGame()
func generateCombinations(remainingLetters: [Character], currentCombination: [LetterTile], usedTiles: Set<LetterTile>) -> [[LetterTile]]
func didBegin(_ contact: SKPhysicsContact)
func withUnsafeBytes<ResultType, ContentType>(_ completion: (UnsafePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
public func register(delegate: EngineDelegate)
public func start(request: URLRequest)
public func stop(closeCode: UInt16 = CloseCode.normal.rawValue)
public func forceStop()
public func write(string: String, completion: (() -> ())?)
public func write(data: Data, opcode: FrameOpCode, completion: (() -> ())?)
public func connectionChanged(state: ConnectionState)
public func didReceiveHTTP(event: HTTPEvent)
public func frameProcessed(event: FrameEvent)
public func decompress(data: Data, isFinal: Bool) -> Data?
public func didForm(event: FrameCollector.Event)
public func add(frame: Frame)
func reset()
public func add(data: Data)
public func register(delegate: FramerEventClient)
public func createWriteFrame(opcode: FrameOpCode, payload: Data, isCompressed: Bool) -> Data
func readUint16(offset: Int) -> UInt16
func readUint64(offset: Int) -> UInt64
func unmaskData(maskStart: Int, offset: Int, length: Int) -> Data
public func writeUint16( _ buffer: inout [UInt8], offset: Int, value: UInt16)
public func writeUint32( _ buffer: inout [UInt8], offset: Int, value: UInt32)
public func writeUint64( _ buffer: inout [UInt8], offset: Int, value: UInt64)
func getParts() -> URLParts?
public func evaluateTrust(trust: SecTrust, domain: String?, completion: ((PinningState) -> ()))
public func validate(headers: [String: String], key: String) -> Error?
func sha1Base64() -> String
public func write(string: String)
public func write(data: Data)
public func write(ping: Data)
public func write(pong: Data)
public func disconnect()
func didError(reason: String)
open func connect()
open func didError(reason: String)
open func disconnect(reason: String)
open func doFastUpgrade()
open func flushWaitingForPostToWebSocket()
open func parseEngineData(_ data: Data)
open func parseEngineMessage(_ message: String)
open func setConfigs(_ config: SocketIOClientConfiguration)
open func write(_ msg: String, withType type: SocketEnginePacketType, withData data: [Data], completion: (() -> ())? = nil)
func setConnected(_ value: Bool)
public func URLSession(session: URLSession, didBecomeInvalidWithError error: NSError?)
public func didReceive(event: Starscream.WebSocketEvent, client: Starscream.WebSocketClient)
func createRequestForPostWithPostWait() -> URLRequest
public func doPoll()
func doRequest(for req: URLRequest, callbackWith callback: @escaping (Data?, URLResponse?, Error?) -> ())
func doLongPoll(for req: URLRequest)
func parsePollingMessage(_ str: String)
public func sendPollMessage(_ message: String, withType type: SocketEnginePacketType, withData datas: [Data], completion: (() -> ())? = nil)
public func stopPolling()
func addHeaders(to req: inout URLRequest, includingCookies additionalCookies: [HTTPCookie]? = nil)
func createBinaryDataForSend(using data: Data) -> Either<Data, String>
func send(_ msg: String, withData datas: [Data], completion: (() -> ())? = nil)
func probeWebSocket()
public func sendWebSocketMessage(_ str: String,
public func sendWebSocketMessage(_ str: String,
static func packetFromEmit(_ items: [Any], id: Int, nsp: String, ack: Bool, checkForBinary: Bool = true) -> SocketPacket
static func shred(_ data: Any, binary: inout [Data]) -> Any
static func deconstructData(_ data: [Any]) -> ([Any], [Data])
internal func parseString(_ message: String) throws -> SocketPacket
func parseSocketMessage(_ message: String) -> SocketPacket?
func parseBinaryData(_ data: Data) -> SocketPacket?
func toJSON() throws -> Data
func toSocketConfiguration() -> SocketIOClientConfiguration
func toArray() throws -> [Any]
func toDictionary() throws -> [String: Any]
func urlEncode() -> String?
func log(_ message: @autoclosure () -> String, type: String)
func error(_ message: @autoclosure () -> String, type: String)
func socketRepresentation() -> SocketData
func socketRepresentation() throws -> SocketData
func groupTilesByProximity(tiles: [MockLetterTile], radius: CGFloat) -> [[MockLetterTile]]
func validateWordsMatch(target: [String], found: [String]) -> Bool
static func == (lhs: MockLetterTile, rhs: MockLetterTile) -> Bool
func hash(into hasher: inout Hasher)
func findBestTileCombination(for targetLetters: [Character], from allTiles: [MockLetterTile], excluding usedTiles: Set<MockLetterTile>) -> [MockLetterTile]?
func generateTileCombinations(for targetLetters: [Character], from tilesByLetter: [Character: [MockLetterTile]]) -> [[MockLetterTile]]
func generateCombinations(remainingLetters: [Character], currentCombination: [MockLetterTile], usedTiles: Set<MockLetterTile>) -> [[MockLetterTile]]
func startNewGame(isUserInitiated: Bool = false) async
func resetGame()
func validateWordCompletion(formedWords: [String]) -> Bool
func checkWordFromTiles(at positions: [CGPoint]) -> String?
func getExpectedWords() -> [String]
func completeGame()
func skipCurrentGame() async
func addHint(_ hint: String)
func connect(playerId: String)
func disconnect()
func registerPlayer(name: String) async -> Bool
func fetchOnlinePlayers() async
func sendPhrase(content: String, targetId: String, clue: String? = nil, language: String = "en") async -> Bool
func fetchPhrasesForCurrentPlayer() async -> [CustomPhrase]
func consumePhrase(phraseId: String) async -> Bool
func skipPhrase(phraseId: String) async -> Bool
func getPhrasePreview(phraseId: String) async -> PhrasePreview?
func useHint(phraseId: String, level: Int) async -> HintResponse?
func getHintStatus(phraseId: String) async -> HintStatus?
func completePhrase(phraseId: String, completionTime: Int = 0) async -> CompletionResult?
func startPeriodicPlayerListFetch()
func stopPeriodicPlayerListFetch()
func getPlayerStats(playerId: String) async throws -> PlayerStats
func getLeaderboard(period: String, limit: Int = 10) async throws -> [LeaderboardEntry]
func getOnlinePlayersCount() async throws -> Int
func testConnection() async -> Result<Bool, NetworkError>
func connect()
func sendManualPing()
func analyzeDifficulty(phrase: String, language: String = "en") async -> DifficultyAnalysis?
func withTimeout<T>(seconds: TimeInterval, operation: @escaping () async throws -> T) async throws -> T
func updateScoreTile()
func updateLanguageTile()
func updateGravity(from gravity: CMAcceleration)
func triggerQuake()
func triggerQuickQuake()
func triggerHint()
func showHint1()
func showHint2()
func showHint3()
func resetGame()
func generateCombinations(remainingLetters: [Character], currentCombination: [LetterTile], usedTiles: Set<LetterTile>) -> [[LetterTile]]
func didBegin(_ contact: SKPhysicsContact)
func withUnsafeBytes<ResultType, ContentType>(_ completion: (UnsafePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
public func register(delegate: EngineDelegate)
public func start(request: URLRequest)
public func stop(closeCode: UInt16 = CloseCode.normal.rawValue)
public func forceStop()
public func write(string: String, completion: (() -> ())?)
public func write(data: Data, opcode: FrameOpCode, completion: (() -> ())?)
public func connectionChanged(state: ConnectionState)
public func didReceiveHTTP(event: HTTPEvent)
public func frameProcessed(event: FrameEvent)
public func decompress(data: Data, isFinal: Bool) -> Data?
public func didForm(event: FrameCollector.Event)
public func add(frame: Frame)
func reset()
public func add(data: Data)
public func register(delegate: FramerEventClient)
public func createWriteFrame(opcode: FrameOpCode, payload: Data, isCompressed: Bool) -> Data
func readUint16(offset: Int) -> UInt16
func readUint64(offset: Int) -> UInt64
func unmaskData(maskStart: Int, offset: Int, length: Int) -> Data
public func writeUint16( _ buffer: inout [UInt8], offset: Int, value: UInt16)
public func writeUint32( _ buffer: inout [UInt8], offset: Int, value: UInt32)
public func writeUint64( _ buffer: inout [UInt8], offset: Int, value: UInt64)
func getParts() -> URLParts?
public func evaluateTrust(trust: SecTrust, domain: String?, completion: ((PinningState) -> ()))
public func validate(headers: [String: String], key: String) -> Error?
func sha1Base64() -> String
public func write(string: String)
public func write(data: Data)
public func write(ping: Data)
public func write(pong: Data)
public func disconnect()
func didError(reason: String)
open func connect()
open func didError(reason: String)
open func disconnect(reason: String)
open func doFastUpgrade()
open func flushWaitingForPostToWebSocket()
open func parseEngineData(_ data: Data)
open func parseEngineMessage(_ message: String)
open func setConfigs(_ config: SocketIOClientConfiguration)
open func write(_ msg: String, withType type: SocketEnginePacketType, withData data: [Data], completion: (() -> ())? = nil)
func setConnected(_ value: Bool)
public func URLSession(session: URLSession, didBecomeInvalidWithError error: NSError?)
public func didReceive(event: Starscream.WebSocketEvent, client: Starscream.WebSocketClient)
func createRequestForPostWithPostWait() -> URLRequest
public func doPoll()
func doRequest(for req: URLRequest, callbackWith callback: @escaping (Data?, URLResponse?, Error?) -> ())
func doLongPoll(for req: URLRequest)
func parsePollingMessage(_ str: String)
public func sendPollMessage(_ message: String, withType type: SocketEnginePacketType, withData datas: [Data], completion: (() -> ())? = nil)
public func stopPolling()
func addHeaders(to req: inout URLRequest, includingCookies additionalCookies: [HTTPCookie]? = nil)
func createBinaryDataForSend(using data: Data) -> Either<Data, String>
func send(_ msg: String, withData datas: [Data], completion: (() -> ())? = nil)
func probeWebSocket()
public func sendWebSocketMessage(_ str: String,
public func sendWebSocketMessage(_ str: String,
static func packetFromEmit(_ items: [Any], id: Int, nsp: String, ack: Bool, checkForBinary: Bool = true) -> SocketPacket
static func shred(_ data: Any, binary: inout [Data]) -> Any
static func deconstructData(_ data: [Any]) -> ([Any], [Data])
internal func parseString(_ message: String) throws -> SocketPacket
func parseSocketMessage(_ message: String) -> SocketPacket?
func parseBinaryData(_ data: Data) -> SocketPacket?
func toJSON() throws -> Data
func toSocketConfiguration() -> SocketIOClientConfiguration
func toArray() throws -> [Any]
func toDictionary() throws -> [String: Any]
func urlEncode() -> String?
func log(_ message: @autoclosure () -> String, type: String)
func error(_ message: @autoclosure () -> String, type: String)
func socketRepresentation() -> SocketData
func socketRepresentation() throws -> SocketData
func groupTilesByProximity(tiles: [MockLetterTile], radius: CGFloat) -> [[MockLetterTile]]
func validateWordsMatch(target: [String], found: [String]) -> Bool
static func == (lhs: MockLetterTile, rhs: MockLetterTile) -> Bool
func hash(into hasher: inout Hasher)
func findBestTileCombination(for targetLetters: [Character], from allTiles: [MockLetterTile], excluding usedTiles: Set<MockLetterTile>) -> [MockLetterTile]?
func generateTileCombinations(for targetLetters: [Character], from tilesByLetter: [Character: [MockLetterTile]]) -> [[MockLetterTile]]
func generateCombinations(remainingLetters: [Character], currentCombination: [MockLetterTile], usedTiles: Set<MockLetterTile>) -> [[MockLetterTile]]
func startNewGame(isUserInitiated: Bool = false) async
func resetGame()
func validateWordCompletion(formedWords: [String]) -> Bool
func checkWordFromTiles(at positions: [CGPoint]) -> String?
func getExpectedWords() -> [String]
func completeGame()
func skipCurrentGame() async
func addHint(_ hint: String)
func connect(playerId: String)
func disconnect()
func registerPlayer(name: String) async -> Bool
func fetchOnlinePlayers() async
func sendPhrase(content: String, targetId: String, clue: String? = nil, language: String = "en") async -> Bool
func fetchPhrasesForCurrentPlayer() async -> [CustomPhrase]
func consumePhrase(phraseId: String) async -> Bool
func skipPhrase(phraseId: String) async -> Bool
func getPhrasePreview(phraseId: String) async -> PhrasePreview?
func useHint(phraseId: String, level: Int) async -> HintResponse?
func getHintStatus(phraseId: String) async -> HintStatus?
func completePhrase(phraseId: String, completionTime: Int = 0) async -> CompletionResult?
func startPeriodicPlayerListFetch()
func stopPeriodicPlayerListFetch()
func getPlayerStats(playerId: String) async throws -> PlayerStats
func getLeaderboard(period: String, limit: Int = 10) async throws -> [LeaderboardEntry]
func getOnlinePlayersCount() async throws -> Int
func testConnection() async -> Result<Bool, NetworkError>
func connect()
func sendManualPing()
func analyzeDifficulty(phrase: String, language: String = "en") async -> DifficultyAnalysis?
func withTimeout<T>(seconds: TimeInterval, operation: @escaping () async throws -> T) async throws -> T
func updateScoreTile()
func updateLanguageTile()
func updateGravity(from gravity: CMAcceleration)
func triggerQuake()
func triggerQuickQuake()
func triggerHint()
func showHint1()
func showHint2()
func showHint3()
func resetGame()
func generateCombinations(remainingLetters: [Character], currentCombination: [LetterTile], usedTiles: Set<LetterTile>) -> [[LetterTile]]
func didBegin(_ contact: SKPhysicsContact)
func withUnsafeBytes<ResultType, ContentType>(_ completion: (UnsafePointer<ContentType>) throws -> ResultType) rethrows -> ResultType
public func register(delegate: EngineDelegate)
public func start(request: URLRequest)
public func stop(closeCode: UInt16 = CloseCode.normal.rawValue)
public func forceStop()
public func write(string: String, completion: (() -> ())?)
public func write(data: Data, opcode: FrameOpCode, completion: (() -> ())?)
public func connectionChanged(state: ConnectionState)
public func didReceiveHTTP(event: HTTPEvent)
public func frameProcessed(event: FrameEvent)
public func decompress(data: Data, isFinal: Bool) -> Data?
public func didForm(event: FrameCollector.Event)
public func add(frame: Frame)
func reset()
public func add(data: Data)
public func register(delegate: FramerEventClient)
public func createWriteFrame(opcode: FrameOpCode, payload: Data, isCompressed: Bool) -> Data
func readUint16(offset: Int) -> UInt16
func readUint64(offset: Int) -> UInt64
func unmaskData(maskStart: Int, offset: Int, length: Int) -> Data
public func writeUint16( _ buffer: inout [UInt8], offset: Int, value: UInt16)
public func writeUint32( _ buffer: inout [UInt8], offset: Int, value: UInt32)
public func writeUint64( _ buffer: inout [UInt8], offset: Int, value: UInt64)
func getParts() -> URLParts?
public func evaluateTrust(trust: SecTrust, domain: String?, completion: ((PinningState) -> ()))
public func validate(headers: [String: String], key: String) -> Error?
func sha1Base64() -> String
public func write(string: String)
public func write(data: Data)
public func write(ping: Data)
public func write(pong: Data)
public func disconnect()
func didError(reason: String)
open func connect()
open func didError(reason: String)
open func disconnect(reason: String)
open func doFastUpgrade()
open func flushWaitingForPostToWebSocket()
open func parseEngineData(_ data: Data)
open func parseEngineMessage(_ message: String)
open func setConfigs(_ config: SocketIOClientConfiguration)
open func write(_ msg: String, withType type: SocketEnginePacketType, withData data: [Data], completion: (() -> ())? = nil)
func setConnected(_ value: Bool)
public func URLSession(session: URLSession, didBecomeInvalidWithError error: NSError?)
public func didReceive(event: Starscream.WebSocketEvent, client: Starscream.WebSocketClient)
func createRequestForPostWithPostWait() -> URLRequest
public func doPoll()
func doRequest(for req: URLRequest, callbackWith callback: @escaping (Data?, URLResponse?, Error?) -> ())
func doLongPoll(for req: URLRequest)
func parsePollingMessage(_ str: String)
public func sendPollMessage(_ message: String, withType type: SocketEnginePacketType, withData datas: [Data], completion: (() -> ())? = nil)
public func stopPolling()
func addHeaders(to req: inout URLRequest, includingCookies additionalCookies: [HTTPCookie]? = nil)
func createBinaryDataForSend(using data: Data) -> Either<Data, String>
func send(_ msg: String, withData datas: [Data], completion: (() -> ())? = nil)
func probeWebSocket()
public func sendWebSocketMessage(_ str: String,
public func sendWebSocketMessage(_ str: String,
static func packetFromEmit(_ items: [Any], id: Int, nsp: String, ack: Bool, checkForBinary: Bool = true) -> SocketPacket
static func shred(_ data: Any, binary: inout [Data]) -> Any
static func deconstructData(_ data: [Any]) -> ([Any], [Data])
internal func parseString(_ message: String) throws -> SocketPacket
func parseSocketMessage(_ message: String) -> SocketPacket?
func parseBinaryData(_ data: Data) -> SocketPacket?
func toJSON() throws -> Data
func toSocketConfiguration() -> SocketIOClientConfiguration
func toArray() throws -> [Any]
func toDictionary() throws -> [String: Any]
func urlEncode() -> String?
func log(_ message: @autoclosure () -> String, type: String)
func error(_ message: @autoclosure () -> String, type: String)
func socketRepresentation() -> SocketData
func socketRepresentation() throws -> SocketData
public func sendWebSocketMessage(_ str: String,
public func sendWebSocketMessage(_ str: String,
public func sendWebSocketMessage(_ str: String,

extension MockLetterTile: Hashable   {
}
extension DateFormatter {
}
extension PhysicsGameScene: SKPhysicsContactDelegate   {
}
internal extension Data {
}
extension UInt8: MyWSArrayType   {
}
public extension URL {
}
extension FoundationSecurity: CertificatePinning   {
}
extension FoundationSecurity: HeaderValidator   {
}
private extension String {
}
extension WebSocketClient {
}
extension URL {
}
public extension SocketIOClientSpec {
}
extension SocketEngine {
}
extension SocketEngine {
}
extension SocketEnginePollable {
}
extension SocketEngineSpec {
}
extension SocketEngineWebsocket {
    public func sendWebSocketMessage(_ str: String,
}
public extension SocketPacket {
}
extension SocketPacket {
}
private extension SocketPacket {
}
extension Array {
}
extension CharacterSet {
}
extension String {
}
public extension SocketLogger {
}
public extension SocketData {
}
extension Array : SocketData   {
}
extension MockLetterTile: Hashable    {
}
extension DateFormatter {
}
extension PhysicsGameScene: SKPhysicsContactDelegate    {
}
internal extension Data {
}
extension UInt8: MyWSArrayType    {
}
public extension URL {
}
extension FoundationSecurity: CertificatePinning    {
}
extension FoundationSecurity: HeaderValidator    {
}
private extension String {
}
extension WebSocketClient {
}
extension URL {
}
public extension SocketIOClientSpec {
}
extension SocketEngine {
}
extension SocketEngine {
}
extension SocketEnginePollable {
}
extension SocketEngineSpec {
}
extension SocketEngineWebsocket {
    public func sendWebSocketMessage(_ str: String,
}
public extension SocketPacket {
}
extension SocketPacket {
}
private extension SocketPacket {
}
extension Array {
}
extension CharacterSet {
}
extension String {
}
public extension SocketLogger {
}
public extension SocketData {
}
extension Array : SocketData    {
}
extension MockLetterTile: Hashable     {
}
extension DateFormatter {
}
extension PhysicsGameScene: SKPhysicsContactDelegate     {
}
internal extension Data {
}
extension UInt8: MyWSArrayType     {
}
public extension URL {
}
extension FoundationSecurity: CertificatePinning     {
}
extension FoundationSecurity: HeaderValidator     {
}
private extension String {
}
extension WebSocketClient {
}
extension URL {
}
public extension SocketIOClientSpec {
}
extension SocketEngine {
}
extension SocketEngine {
}
extension SocketEnginePollable {
}
extension SocketEngineSpec {
}
extension SocketEngineWebsocket {
    public func sendWebSocketMessage(_ str: String,
}
public extension SocketPacket {
}
extension SocketPacket {
}
private extension SocketPacket {
}
extension Array {
}
extension CharacterSet {
}
extension String {
}
public extension SocketLogger {
}
public extension SocketData {
}
extension Array : SocketData     {
}

////////////////////////////////////////////////////////////////////////////////////////////////////
