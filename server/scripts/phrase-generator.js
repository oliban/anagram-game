#!/usr/bin/env node

/**
 * Phrase Generator Script
 * 
 * Generates anagram game phrases targeting specific difficulty ranges.
 * Uses AI-powered generation for meaningful, coherent phrases.
 */

const fs = require('fs');
const path = require('path');
const { calculateScore } = require('../../shared/difficulty-algorithm');
const englishPhraseData = require('./phrase-data-en');
const { generateGrammaticallyCorrectPhrases } = require('./ai-phrase-generator');

// Configuration
const CONFIG = {
  maxAttempts: 2000,
  difficultyTolerance: 25,
  outputDir: path.join(__dirname, '../data'),
  defaultLanguage: 'en',
  maxWordLength: 7,
  maxWords: 4,
  minWords: 2
};



/**
 * Get difficulty level category from numeric range
 */
function getDifficultyLevel(minDiff, maxDiff) {
  if (maxDiff <= 50) return 'easy';
  if (maxDiff <= 100) return 'medium';
  if (maxDiff <= 150) return 'hard';
  return 'expert';
}

/**
 * Validate word length constraints
 */
function validateWordLength(phrase) {
  const words = phrase.split(' ');
  
  // Check word count
  if (words.length < CONFIG.minWords || words.length > CONFIG.maxWords) {
    return false;
  }
  
  // Check individual word lengths
  for (const word of words) {
    if (word.length > CONFIG.maxWordLength) {
      return false;
    }
  }
  
  return true;
}



// Static dictionary removed - all clues now generated dynamically by AI

/**
 * Generate clever contextual clue using AI (legacy function - clues now generated with phrases)
 */
function generateClue(phrase, language = 'en') {
  console.log(`üß© Legacy clue generation called for "${phrase}" (${language}) - should use AI generation instead`);
  
  // All clues are now generated by AI along with phrases
  throw new Error('Legacy clue generation deprecated - use AI generation with phrases');
}

/**
 * Legacy fallback clue function - NO LONGER USED
 * All clues are now generated dynamically by AI along with phrases
 */
function generateFallbackClue(phrase, language = 'en') {
  throw new Error('Generic fallback clues are forbidden - all clues must be AI-generated and clever');
}

/**
 * Generate AI-powered phrases using the universal AI system
 */
async function generateAIPhrases(difficultyRange, count, language, difficultyLevel) {
  console.log(`ü§ñ Using universal AI to generate ${count} high-quality phrases for ${difficultyRange} (${language})`);
  
  try {
    // Use the same AI system for both English and Swedish
    const aiPhrases = await generateGrammaticallyCorrectPhrases(count, difficultyLevel, language);
    return aiPhrases;
  } catch (error) {
    console.error(`üö® AI phrase generation failed: ${error.message}`);
    throw new Error(`${language} phrase generation failed: ${error.message}`);
  }
}

/**
 * Create AI prompts for phrase generation
 */
function createAIPrompts(difficultyRange, count, language, difficultyLevel) {
  const [minDiff, maxDiff] = difficultyRange.split('-').map(n => parseInt(n));
  
  const basePrompt = language === 'sv' 
    ? `Generera ${count} meningsfulla svenska fraser f√∂r ordpussel (sv√•righetsgrad: ${difficultyLevel}). 
       Varje fras ska vara 2-4 ord (max 7 bokst√§ver per ord) med korrekt svensk grammatik (adjektiv-substantiv √∂verensst√§mmelse).
       
       F√∂r varje fras, skapa ocks√• en KLYFTIG ledtr√•d som:
       - Kr√§ver lateral t√§nkande, inte bara beskriver vad frasen betyder
       - Anv√§nder kulturella referenser, metaforer, eller kreativa associationer
       - Aldrig inneh√•ller ord fr√•n sj√§lva frasen
       - √Ñr en pusselg√•ta i sig sj√§lv
       
       Exempel p√• klyftig ledtr√•d-stil:
       - "kall vinter" ‚Üí "Sn√∂gubbens favorit√•rstid" 
       - "varm sol" ‚Üí "Solpanelens b√§sta v√§n"
       - "lugn sj√∂" ‚Üí "Naturens perfekta spegel"
       
       Returnera exakt denna JSON-format:
       [
         {"phrase": "mjukt regn", "clue": "Paraplyers mjuka p√•minnelse"},
         {"phrase": "glatt barn", "clue": "Lekplatsens skrattmaskin"}
       ]`
    : `Generate ${count} meaningful English phrases for word puzzles (difficulty: ${difficultyLevel}).
       Each phrase should be 2-4 words (max 7 letters per word) that create logical, coherent expressions.
       
       For each phrase, also create a CLEVER clue that:
       - Requires lateral thinking, not just describing what the phrase means
       - Uses cultural references, metaphors, or creative associations  
       - Never contains words from the phrase itself
       - Is a mini-puzzle to solve
       
       Examples of clever clue style:
       - "cold winter" ‚Üí "Jack Frost's favorite season"
       - "fresh air" ‚Üí "What city dwellers crave most"
       - "happy child" ‚Üí "Playground giggles source"
       
       Return exactly this JSON format:
       [
         {"phrase": "bright star", "clue": "Navigator's ancient GPS"},
         {"phrase": "calm lake", "clue": "Nature's perfect mirror"}
       ]`;
  
  return [basePrompt];
}

/**
 * Generate meaningful phrases AND clever clues using single AI call
 */
async function generateMeaningfulPhrases(prompt, language, difficultyLevel) {
  console.log(`ü§ñ Generating phrases AND clever clues with AI: ${prompt.substring(0, 100)}...`);
  
  try {
    // Use Task tool to generate both phrases and clever clues in one call
    const aiResult = await useTaskTool(prompt, language, difficultyLevel);
    return aiResult;
  } catch (error) {
    console.warn(`‚ö†Ô∏è AI generation failed: ${error.message}`);
    return [];
  }
}

/**
 * Use Task tool to generate phrases with AI (placeholder for now)  
 */
async function useTaskTool(prompt, language, difficultyLevel) {
  // TODO: Replace with actual Task tool when available
  console.log(`ü§ñ AI generating ${language} phrases AND clever clues...`);
  
  try {
    // Simulate AI that returns both phrases and clever clues in one call
    const result = await simulateAIGenerationWithClues(language, difficultyLevel);
    return result.map(item => ({
      phrase: item.phrase,
      clue: item.clue,
      source: 'ai_generated',
      generated_at: new Date().toISOString()
    }));
  } catch (error) {
    throw new Error(`AI generation failed: ${error.message}`);
  }
}

/**
 * Simulate AI generation with phrases AND clever clues (temporary until Task tool integration)
 */
async function simulateAIGenerationWithClues(language, difficultyLevel) {
  // This simulates what real AI would generate: both phrases and clever clues together
  const aiGeneratedData = {
    en: {
      easy: () => generateEnglishPhrasesWithClues('easy'),
      medium: () => generateEnglishPhrasesWithClues('medium'), 
      hard: () => generateEnglishPhrasesWithClues('hard'),
      expert: () => generateEnglishPhrasesWithClues('expert')
    },
    sv: {
      easy: () => generateSwedishPhrasesWithClues('easy'),
      medium: () => generateSwedishPhrasesWithClues('medium'),
      hard: () => generateSwedishPhrasesWithClues('hard'), 
      expert: () => generateSwedishPhrasesWithClues('expert')
    }
  };
  
  const generator = aiGeneratedData[language]?.[difficultyLevel] || aiGeneratedData.en.easy;
  return generator();
}

/**
 * Generate English phrases WITH clever clues (AI simulation)
 */
function generateEnglishPhrasesWithClues(level) {
  const phrases = englishPhraseData[level] || englishPhraseData.easy;
  // Shuffle to get variety
  return phrases.sort(() => Math.random() - 0.5).slice(0, 15);
}

/**
 * Generate Swedish phrases using PURE AI with BATCH validation - no hardcoded lists!
 */
async function generateSwedishPhrasesWithClues(level) {
  console.log(`ü§ñ AI generating grammatically perfect Swedish phrases for level: ${level}`);
  
  try {
    // Use AI to generate Swedish phrases with perfect grammar
    const aiPhrases = await generateGrammaticallyCorrectSwedishPhrases(15, level);
    
    // BATCH validate all phrases at once with AI
    const phrasesToValidate = aiPhrases.map(p => p.phrase);
    console.log(`üîç BATCH validating ${phrasesToValidate.length} Swedish phrases...`);
    
    const { validateSwedishGrammarBatch } = require('./ai-swedish-grammar');
    const validationResults = await validateSwedishGrammarBatch(phrasesToValidate);
    
    // Process validation results
    const validatedPhrases = [];
    for (let i = 0; i < aiPhrases.length; i++) {
      const phraseObj = aiPhrases[i];
      const validation = validationResults[i];
      
      if (!validation.is_correct) {
        console.warn(`‚ö†Ô∏è AI detected grammar issue: "${phraseObj.phrase}"`);
        console.log(`‚úÖ AI corrected to: "${validation.corrected_phrase}"`);
        console.log(`üí° AI explanation: ${validation.explanation}`);
        
        validatedPhrases.push({
          phrase: validation.corrected_phrase,
          clue: phraseObj.clue
        });
      } else {
        validatedPhrases.push(phraseObj);
      }
    }
    
    return validatedPhrases;
    
  } catch (error) {
    console.error('üö® AI Swedish generation failed:', error.message);
    // NO FALLBACK - Pure AI generation only
    throw new Error(`Swedish phrase generation failed: ${error.message}`);
  }
}

/**
 * Generate phrases for a specific difficulty range using AI - ITERATE UNTIL TARGET COUNT
 */
async function generatePhrasesForRange(minDiff, maxDiff, targetCount, language = 'en') {
  console.log(`üéØ Generating ${targetCount} AI-powered phrases for difficulty range ${minDiff}-${maxDiff} (${language})`);
  
  const difficultyLevel = getDifficultyLevel(minDiff, maxDiff);
  const difficultyRange = `${minDiff}-${maxDiff}`;
  
  const generatedPhrases = [];
  const seenPhrases = new Set();
  let totalProcessed = 0;
  let attempts = 0;
  const maxAttempts = 10; // Prevent infinite loops
  
  // ITERATE until we get the target count
  while (generatedPhrases.length < targetCount && attempts < maxAttempts) {
    attempts++;
    const batchSize = Math.max(50, targetCount - generatedPhrases.length);
    
    console.log(`üîÑ Attempt ${attempts}: Generating batch of ${batchSize} phrases (need ${targetCount - generatedPhrases.length} more)`);
    
    // Generate meaningful phrases using AI
    const aiPhrases = await generateAIPhrases(difficultyRange, batchSize, language, difficultyLevel);
    
    for (const aiPhrase of aiPhrases) {
      totalProcessed++;
      const phrase = aiPhrase.phrase;
      const clue = aiPhrase.clue;
      
      // Skip if phrase doesn't meet length constraints
      if (!validateWordLength(phrase)) {
        console.log(`‚ö†Ô∏è Skipping "${phrase}" (violates length constraints)`);
        continue;
      }
      
      // Skip if we've seen this phrase before
      if (seenPhrases.has(phrase.toLowerCase())) {
        continue;
      }
      seenPhrases.add(phrase.toLowerCase());
      
      // Calculate difficulty score
      try {
        const difficulty = calculateScore({ phrase, language });
        const roundedDifficulty = Math.round(difficulty);
        
        // Check if it fits the target range (with tolerance)
        if (roundedDifficulty >= (minDiff - CONFIG.difficultyTolerance) && 
            roundedDifficulty <= (maxDiff + CONFIG.difficultyTolerance)) {
          
          generatedPhrases.push({
            phrase: phrase,
            clue: clue,
            difficulty: roundedDifficulty,
            language: language,
            source: 'ai_generated',
            generated_at: new Date().toISOString()
          });
          
          if (generatedPhrases.length % 25 === 0) {
            console.log(`üìä Generated ${generatedPhrases.length}/${targetCount} phrases (${totalProcessed} total processed)`);
          }
          
          // Stop this batch when we have enough
          if (generatedPhrases.length >= targetCount) {
            break;
          }
        } else {
          console.log(`‚ö†Ô∏è "${phrase}" difficulty ${roundedDifficulty} outside target range ${minDiff}-${maxDiff}`);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Error calculating difficulty for "${phrase}": ${error.message}`);
      }
    }
  }
  
  console.log(`‚úÖ Generated ${generatedPhrases.length} AI-powered phrases from ${totalProcessed} candidates in ${attempts} attempts`);
  return generatedPhrases;
}

/**
 * Parse command line arguments
 */
function parseArgs() {
  const args = process.argv.slice(2);
  const parsed = {
    range: null,
    count: 100,
    output: null,
    language: 'en',
    help: false
  };
  
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--range':
        parsed.range = args[++i];
        break;
      case '--count':
        parsed.count = parseInt(args[++i]);
        break;
      case '--output':
        parsed.output = args[++i];
        break;
      case '--language':
        parsed.language = args[++i];
        break;
      case '--help':
      case '-h':
        parsed.help = true;
        break;
    }
  }
  
  return parsed;
}

/**
 * Show help information
 */
function showHelp() {
  console.log(`
üìù Phrase Generator Script

Usage:
  node phrase-generator.js --range "MIN-MAX" --count COUNT [options]

Options:
  --range "MIN-MAX"    Difficulty range (e.g., "0-50", "200-250")
  --count COUNT        Number of phrases to generate (default: 100)
  --output FILE        Output JSON file (default: auto-generated)
  --language LANG      Language code (default: en)
  --help, -h          Show this help

Examples:
  node phrase-generator.js --range "0-50" --count 100
  node phrase-generator.js --range "200-250" --count 50 --output expert-phrases.json
  node phrase-generator.js --range "101-150" --count 75 --language sv
`);
}

/**
 * Main execution function
 */
async function main() {
  const args = parseArgs();
  
  if (args.help) {
    showHelp();
    process.exit(0);
  }
  
  if (!args.range) {
    console.error('‚ùå Error: --range parameter is required');
    console.error('Use --help for usage information');
    process.exit(1);
  }
  
  // Parse range
  const rangeParts = args.range.split('-');
  if (rangeParts.length !== 2) {
    console.error('‚ùå Error: Range must be in format "MIN-MAX" (e.g., "0-50")');
    process.exit(1);
  }
  
  const minDiff = parseInt(rangeParts[0]);
  const maxDiff = parseInt(rangeParts[1]);
  
  if (isNaN(minDiff) || isNaN(maxDiff) || minDiff >= maxDiff) {
    console.error('‚ùå Error: Invalid range. MIN must be less than MAX and both must be numbers');
    process.exit(1);
  }
  
  // Generate output filename if not specified
  if (!args.output) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19); // YYYY-MM-DDTHH-MM-SS
    args.output = path.join(CONFIG.outputDir, `phrases-${args.language}-${minDiff}-${maxDiff}-${args.count}-${timestamp}.json`);
  } else if (!path.isAbsolute(args.output)) {
    args.output = path.join(CONFIG.outputDir, args.output);
  }
  
  // Ensure output directory exists
  fs.mkdirSync(path.dirname(args.output), { recursive: true });
  
  console.log(`üöÄ Starting phrase generation...`);
  console.log(`   Range: ${minDiff}-${maxDiff}`);
  console.log(`   Count: ${args.count}`);
  console.log(`   Language: ${args.language}`);
  console.log(`   Output: ${args.output}`);
  
  try {
    // Generate phrases
    const phrases = await generatePhrasesForRange(minDiff, maxDiff, args.count, args.language);
    
    // Create output data
    const output = {
      metadata: {
        generated_at: new Date().toISOString(),
        target_range: `${minDiff}-${maxDiff}`,
        requested_count: args.count,
        actual_count: phrases.length,
        language: args.language,
        generator_version: '1.0.0'
      },
      phrases: phrases
    };
    
    // Write to file
    fs.writeFileSync(args.output, JSON.stringify(output, null, 2));
    
    // Show statistics
    const difficultyStats = {};
    phrases.forEach(p => {
      const bucket = Math.floor(p.difficulty / 10) * 10;
      const key = `${bucket}-${bucket + 9}`;
      difficultyStats[key] = (difficultyStats[key] || 0) + 1;
    });
    
    console.log(`\nüìä Generation Complete!`);
    console.log(`   Generated: ${phrases.length} phrases`);
    console.log(`   Success rate: ${((phrases.length / args.count) * 100).toFixed(1)}%`);
    console.log(`   Output file: ${args.output}`);
    console.log(`   Difficulty distribution:`);
    Object.entries(difficultyStats).sort().forEach(([range, count]) => {
      console.log(`     ${range}: ${count} phrases`);
    });
    
  } catch (error) {
    console.error(`‚ùå Generation failed: ${error.message}`);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main().catch(error => {
    console.error('‚ùå Unexpected error:', error);
    process.exit(1);
  });
}

module.exports = {
  generatePhrasesForRange,
  generateClue
};